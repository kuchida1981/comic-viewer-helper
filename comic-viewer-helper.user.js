// ==UserScript==
// @name            Magazine Comic Viewer Helper
// @name:ja         ãƒžã‚¬ã‚¸ãƒ³ãƒ»ã‚³ãƒŸãƒƒã‚¯ãƒ»ãƒ“ãƒ¥ãƒ¼ã‚¢ãƒ»ãƒ˜ãƒ«ãƒ‘ãƒ¼
// @author          kuchida1981
// @namespace       https://github.com/kuchida1981/comic-viewer-helper
// @version         1.3.0-unstable.44aed67
// @description     A Tampermonkey script for specific comic sites that fits images to the viewport and enables precise image-by-image scrolling.
// @description:ja  ç‰¹å®šã®æ¼«ç”»ã‚µã‚¤ãƒˆã§ç”»åƒã‚’ãƒ“ãƒ¥ãƒ¼ãƒãƒ¼ãƒˆã«åˆã‚ã›ã€ç”»åƒå˜ä½ã®ã‚¹ã‚¯ãƒ­ãƒ¼ãƒ«ã‚’å¯èƒ½ã«ã™ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã‚¹ã‚¯ãƒªãƒ—ãƒˆã§ã™ã€‚
// @license         ISC
// @match           https://something/magazine/*
// @match           https://something/fanzine/*
// @updateURL       https://raw.githubusercontent.com/kuchida1981/comic-viewer-helper/unstable/comic-viewer-helper.user.js
// @downloadURL     https://raw.githubusercontent.com/kuchida1981/comic-viewer-helper/unstable/comic-viewer-helper.user.js
// @run-at          document-idle
// @grant           none
// ==/UserScript==

/**
 * âš ï¸ DO NOT EDIT THIS FILE DIRECTLY âš ï¸
 * This file is automatically generated by the build process.
 * Please edit files in the `src/` directory instead and run `npm run build`.
 */
(function() {
  "use strict";
  const STORAGE_KEYS = {
    DUAL_VIEW: "comic-viewer-helper-dual-view",
    GUI_POS: "comic-viewer-helper-gui-pos",
    ENABLED: "comic-viewer-helper-enabled",
    SEARCH_QUERY: "comic-viewer-helper-search-query",
    SEARCH_CACHE: "comic-viewer-helper-search-cache"
  };
  class Store {
    state;
    listeners;
    constructor() {
      this.state = {
        enabled: localStorage.getItem(STORAGE_KEYS.ENABLED) !== "false",
        isDualViewEnabled: localStorage.getItem(STORAGE_KEYS.DUAL_VIEW) === "true",
        spreadOffset: 0,
        currentVisibleIndex: 0,
        guiPos: this._loadGuiPos(),
        metadata: {
          title: "",
          tags: [],
          relatedWorks: []
        },
        isMetadataModalOpen: false,
        isHelpModalOpen: false,
        isSearchModalOpen: false,
        isLoading: false,
        searchResults: null,
        searchQuery: this._loadSearchQuery(),
        searchCache: this._loadSearchCache()
      };
      this.listeners = [];
    }
    getState() {
      return { ...this.state };
    }
    setState(patch) {
      let changed = false;
      for (const key of Object.keys(patch)) {
        if (this.state[key] !== patch[key]) {
          this._applyPatch(key, patch[key]);
          changed = true;
        }
      }
      if (!changed) return;
      if ("enabled" in patch) {
        localStorage.setItem(STORAGE_KEYS.ENABLED, String(patch.enabled));
      }
      if ("isDualViewEnabled" in patch) {
        localStorage.setItem(STORAGE_KEYS.DUAL_VIEW, String(patch.isDualViewEnabled));
      }
      if ("guiPos" in patch) {
        localStorage.setItem(STORAGE_KEYS.GUI_POS, JSON.stringify(patch.guiPos));
      }
      const host = window.location.hostname;
      if ("searchQuery" in patch) {
        localStorage.setItem(`${STORAGE_KEYS.SEARCH_QUERY}-${host}`, patch.searchQuery);
      }
      if ("searchCache" in patch) {
        try {
          localStorage.setItem(`${STORAGE_KEYS.SEARCH_CACHE}-${host}`, JSON.stringify(patch.searchCache));
        } catch (e) {
          console.warn("Failed to save search cache to localStorage:", e);
        }
      }
      this._notify();
    }
    subscribe(callback) {
      this.listeners.push(callback);
      return () => {
        this.listeners = this.listeners.filter((l) => l !== callback);
      };
    }
    _notify() {
      this.listeners.forEach((callback) => callback(this.getState()));
    }
    _applyPatch(key, value) {
      this.state[key] = value;
    }
    _loadSearchCache() {
      try {
        const host = window.location.hostname;
        const saved = localStorage.getItem(`${STORAGE_KEYS.SEARCH_CACHE}-${host}`);
        return saved ? JSON.parse(saved) : null;
      } catch {
        return null;
      }
    }
    _loadSearchQuery() {
      const host = window.location.hostname;
      return localStorage.getItem(`${STORAGE_KEYS.SEARCH_QUERY}-${host}`) || "";
    }
    _loadGuiPos() {
      try {
        const saved = localStorage.getItem(STORAGE_KEYS.GUI_POS);
        if (!saved) return null;
        const pos = JSON.parse(saved);
        const buffer = 50;
        if (typeof pos.left !== "number" || typeof pos.top !== "number" || pos.left < -buffer || pos.left > window.innerWidth + buffer || pos.top < -buffer || pos.top > window.innerHeight + buffer) {
          return null;
        }
        return pos;
      } catch {
        return null;
      }
    }
  }
  const CONTAINER_SELECTOR = "#post-comic";
  const TAG_TYPES = ["artist", "character", "circle", "fanzine", "genre", "magazine", "parody"];
  function getTagType(href) {
    try {
      const url = new URL(href);
      const pathname = url.pathname;
      for (const type of TAG_TYPES) {
        if (pathname.startsWith(`/${type}/`)) {
          return type;
        }
      }
      return null;
    } catch {
      return null;
    }
  }
  const DefaultAdapter = {
    // Always match as a fallback (should be checked last)
    match: () => true,
    getContainer: () => document.querySelector(CONTAINER_SELECTOR),
    getImages: () => Array.from(document.querySelectorAll(`${CONTAINER_SELECTOR} img`)),
    searchConfig: {
      baseUrl: "/",
      queryParam: "s"
    },
    getSearchUrl: function(query) {
      const url = new URL(this.searchConfig?.baseUrl || "/", window.location.origin);
      url.searchParams.set(this.searchConfig?.queryParam || "s", query);
      return url.toString();
    },
    getMetadata: () => {
      const title = document.querySelector("h1")?.textContent?.trim() || "Unknown Title";
      const tags = Array.from(document.querySelectorAll("#post-tag a")).map((a) => {
        const href = a.href;
        return {
          text: a.textContent?.trim() || "",
          href,
          type: getTagType(href)
        };
      });
      const relatedWorks = Array.from(document.querySelectorAll(".post-list-image")).map((el) => {
        const anchor = el.closest("a");
        const img = el.querySelector("img");
        const titleEl = el.querySelector("span") || anchor?.querySelector("span");
        const title2 = titleEl?.textContent?.trim() || "Untitled";
        return {
          title: title2,
          href: anchor?.href || "",
          thumb: img?.src || "",
          isPrivate: title2.startsWith("éžå…¬é–‹")
        };
      });
      return { title, tags, relatedWorks };
    },
    parseSearchResults: (doc) => {
      const results = Array.from(doc.querySelectorAll("div.post-list > a")).map((a) => {
        const img = a.querySelector(".post-list-image img");
        const titleEl = a.querySelector(":scope > span");
        return {
          title: titleEl?.textContent?.trim() || "",
          href: a.getAttribute("href") || "",
          thumb: img?.getAttribute("src") || ""
        };
      });
      const totalCount = doc.querySelector("div.page-h > span")?.textContent?.trim() || null;
      const nextPageUrl = doc.querySelector("div.wp-pagenavi a.nextpostslink")?.getAttribute("href") || null;
      const pagination = [];
      const pagenavi = doc.querySelector(".wp-pagenavi");
      if (pagenavi) {
        pagenavi.childNodes.forEach((node) => {
          if (node.nodeType === 1) {
            const el = node;
            if (el.classList.contains("pages")) return;
            const isCurrent = el.classList.contains("current");
            const isNext = el.classList.contains("nextpostslink");
            const isPrev = el.classList.contains("previouspostslink");
            const isExtend = el.classList.contains("extend");
            let type = "page";
            if (isNext) type = "next";
            else if (isPrev) type = "prev";
            else if (isExtend) type = "extend";
            pagination.push({
              label: el.textContent?.trim() || "",
              url: el.getAttribute("href") || null,
              isCurrent,
              type
            });
          }
        });
      }
      return { results, totalCount, nextPageUrl, pagination };
    }
  };
  function calculateVisibleHeight(rect, windowHeight) {
    const visibleTop = Math.max(0, rect.top);
    const visibleBottom = Math.min(windowHeight, rect.bottom);
    return Math.max(0, visibleBottom - visibleTop);
  }
  function shouldPairWithNext(current, next, isDualViewEnabled) {
    if (!isDualViewEnabled) return false;
    if (current.isLandscape) return false;
    if (!next) return false;
    if (next.isLandscape) return false;
    return true;
  }
  function getPrimaryVisibleImageIndex(imgs, windowHeight) {
    if (imgs.length === 0) return -1;
    let maxVisibleHeight = 0;
    let minDistanceToCenter = Infinity;
    let primaryIndex = -1;
    const viewportCenter = windowHeight / 2;
    imgs.forEach((img, index) => {
      const rect = img.getBoundingClientRect();
      const visibleHeight = calculateVisibleHeight(rect, windowHeight);
      if (visibleHeight > 0) {
        const elementCenter = (rect.top + rect.bottom) / 2;
        const distanceToCenter = Math.abs(viewportCenter - elementCenter);
        if (visibleHeight > maxVisibleHeight || visibleHeight === maxVisibleHeight && distanceToCenter < minDistanceToCenter) {
          maxVisibleHeight = visibleHeight;
          minDistanceToCenter = distanceToCenter;
          primaryIndex = index;
        }
      }
    });
    return primaryIndex;
  }
  function getImageElementByIndex(imgs, index) {
    if (index < 0 || index >= imgs.length) return null;
    return imgs[index];
  }
  function cleanupDOM(container) {
    const allImages = Array.from(container.querySelectorAll("img"));
    const wrappers = container.querySelectorAll(".comic-row-wrapper");
    wrappers.forEach((w) => w.remove());
    allImages.forEach((img) => {
      img.style.cssText = "";
    });
    return allImages;
  }
  function fitImagesToViewport(container, spreadOffset = 0, isDualViewEnabled = false) {
    if (!container) return;
    const allImages = cleanupDOM(container);
    const vw = window.innerWidth;
    const vh = window.innerHeight;
    Object.assign(container.style, {
      display: "flex",
      flexDirection: "column",
      alignItems: "center",
      padding: "0",
      margin: "0",
      width: "100%",
      maxWidth: "none"
    });
    for (let i = 0; i < allImages.length; i++) {
      const img = allImages[i];
      const isLandscape = img.naturalWidth > img.naturalHeight;
      let pairWithNext = false;
      const effectiveIndex = i - spreadOffset;
      const isPairingPosition = effectiveIndex >= 0 && effectiveIndex % 2 === 0;
      const isFirstPage = i === 0;
      const isNextLastPage = i + 1 === allImages.length - 1;
      if (isDualViewEnabled && isPairingPosition && i + 1 < allImages.length && !isFirstPage && !isNextLastPage) {
        const nextImg = allImages[i + 1];
        const nextIsLandscape = nextImg.naturalWidth > nextImg.naturalHeight;
        if (shouldPairWithNext({ isLandscape }, { isLandscape: nextIsLandscape }, isDualViewEnabled)) {
          pairWithNext = true;
        }
      }
      const row = document.createElement("div");
      row.className = "comic-row-wrapper";
      Object.assign(row.style, {
        display: "flex",
        justifyContent: "center",
        alignItems: "center",
        width: "100vw",
        maxWidth: "100vw",
        marginLeft: "calc(50% - 50vw)",
        marginRight: "calc(50% - 50vw)",
        height: "100vh",
        marginBottom: "0",
        position: "relative",
        boxSizing: "border-box"
      });
      if (pairWithNext) {
        const nextImg = allImages[i + 1];
        row.style.flexDirection = "row-reverse";
        [img, nextImg].forEach((im) => {
          Object.assign(im.style, {
            maxWidth: "50%",
            maxHeight: "100%",
            width: "auto",
            height: "auto",
            objectFit: "contain",
            margin: "0",
            display: "block"
          });
        });
        row.appendChild(img);
        row.appendChild(nextImg);
        container.appendChild(row);
        i++;
      } else {
        Object.assign(img.style, {
          maxWidth: `${vw}px`,
          maxHeight: `${vh}px`,
          width: "auto",
          height: "auto",
          display: "block",
          margin: "0 auto",
          flexShrink: "0",
          objectFit: "contain"
        });
        row.appendChild(img);
        container.appendChild(row);
      }
    }
  }
  function revertToOriginal(originalImages, container) {
    if (!container) return;
    container.style.cssText = "";
    originalImages.forEach((img) => {
      img.style.cssText = "";
      container.appendChild(img);
    });
    const wrappers = container.querySelectorAll(".comic-row-wrapper");
    wrappers.forEach((w) => w.remove());
  }
  function getClickNavigationDirection(img) {
    const wrapper = img.parentElement;
    if (!wrapper || !wrapper.classList.contains("comic-row-wrapper")) {
      return "next";
    }
    const siblings = Array.from(wrapper.querySelectorAll("img"));
    if (siblings.length < 2) {
      return "next";
    }
    return img === siblings[0] ? "prev" : "next";
  }
  function getNavigationDirection(event, threshold = 50) {
    if (Math.abs(event.deltaY) < threshold) {
      return "none";
    }
    return event.deltaY > 0 ? "next" : "prev";
  }
  async function waitForImageLoad(img, timeout = 5e3) {
    if (img.complete && img.naturalHeight !== 0) {
      return;
    }
    return new Promise((resolve) => {
      const timer = setTimeout(() => {
        cleanup();
        resolve();
      }, timeout);
      const onLoad = () => {
        cleanup();
        resolve();
      };
      const onError = () => {
        cleanup();
        resolve();
      };
      const cleanup = () => {
        clearTimeout(timer);
        img.removeEventListener("load", onLoad);
        img.removeEventListener("error", onError);
      };
      img.addEventListener("load", onLoad);
      img.addEventListener("error", onError);
    });
  }
  function forceImageLoad(img) {
    if (img.getAttribute("loading") === "lazy") {
      img.setAttribute("loading", "eager");
    }
    if ("decode" in img) {
      img.decode().catch(() => {
      });
    }
  }
  function preloadImages(images, currentIndex, count = 3) {
    if (images.length === 0) return;
    for (let i = 1; i <= count; i++) {
      const nextIndex = currentIndex + i;
      if (nextIndex < images.length) {
        const img = images[nextIndex];
        if (!img.complete) {
          img.loading = "eager";
          if ("decode" in img) {
            img.decode().catch(() => {
            });
          }
        }
      }
    }
    for (let i = 1; i <= Math.min(count, 2); i++) {
      const prevIndex = currentIndex - i;
      if (prevIndex >= 0) {
        const img = images[prevIndex];
        if (!img.complete) {
          img.loading = "eager";
          if ("decode" in img) {
            img.decode().catch(() => {
            });
          }
        }
      }
    }
  }
  function jumpToRandomWork(metadata) {
    if (!metadata?.relatedWorks) return;
    const works = metadata.relatedWorks.filter((w) => !w.isPrivate);
    const randomWork = works[Math.floor(Math.random() * works.length)];
    if (randomWork?.href) {
      window.location.href = randomWork.href;
    }
  }
  class Navigator {
    adapter;
    store;
    originalImages;
    _lastEnabled;
    _lastDualView;
    _lastSpreadOffset;
    pendingTargetIndex;
    constructor(adapter, store) {
      this.adapter = adapter;
      this.store = store;
      this.originalImages = [];
      this.getImages = this.getImages.bind(this);
      this.jumpToPage = this.jumpToPage.bind(this);
      this.scrollToImage = this.scrollToImage.bind(this);
      this.scrollToEdge = this.scrollToEdge.bind(this);
      this.applyLayout = this.applyLayout.bind(this);
      this.updatePageCounter = this.updatePageCounter.bind(this);
      this.init = this.init.bind(this);
      this._lastEnabled = void 0;
      this._lastDualView = void 0;
      this._lastSpreadOffset = void 0;
      this.pendingTargetIndex = null;
    }
    init() {
      this.store.subscribe((state) => {
        const layoutChanged = state.enabled !== this._lastEnabled || state.isDualViewEnabled !== this._lastDualView || state.spreadOffset !== this._lastSpreadOffset;
        if (layoutChanged) {
          this.applyLayout();
          this._lastEnabled = state.enabled;
          this._lastDualView = state.isDualViewEnabled;
          this._lastSpreadOffset = state.spreadOffset;
        }
      });
      const initialState = this.store.getState();
      this._lastEnabled = initialState.enabled;
      this._lastDualView = initialState.isDualViewEnabled;
      this._lastSpreadOffset = initialState.spreadOffset;
      const imgs = this.getImages();
      imgs.forEach((img) => {
        if (!img.complete) {
          img.addEventListener("load", () => {
            if (this.pendingTargetIndex !== null) {
              console.log("[Navigator] Skipping auto applyLayout because navigation is pending");
              return;
            }
            requestAnimationFrame(() => this.applyLayout());
          });
        }
      });
      if (initialState.enabled) {
        this.applyLayout();
      }
    }
    getImages() {
      if (this.originalImages.length > 0) return this.originalImages;
      this.originalImages = this.adapter.getImages();
      return this.originalImages;
    }
    updatePageCounter() {
      const state = this.store.getState();
      const { enabled } = state;
      if (!enabled) return;
      const imgs = this.getImages();
      const currentIndex = getPrimaryVisibleImageIndex(imgs, window.innerHeight);
      if (currentIndex !== -1) {
        this.store.setState({ currentVisibleIndex: currentIndex });
        preloadImages(imgs, currentIndex);
      }
    }
    async jumpToPage(pageNumber) {
      const imgs = this.getImages();
      const index = typeof pageNumber === "string" ? parseInt(pageNumber, 10) - 1 : pageNumber - 1;
      const targetImg = getImageElementByIndex(imgs, index);
      console.log(`[Navigator] jumpToPage: ${pageNumber} (index: ${index})`, { complete: targetImg?.complete, height: targetImg?.naturalHeight });
      if (targetImg) {
        this.pendingTargetIndex = index;
        forceImageLoad(targetImg);
        if (!targetImg.complete || targetImg.naturalHeight === 0) {
          console.log(`[Navigator] Waiting for image load...`);
          this.store.setState({ isLoading: true });
          await waitForImageLoad(targetImg);
          console.log(`[Navigator] Image loaded. Applying layout...`);
          this.applyLayout(index);
          this.store.setState({ isLoading: false });
        } else {
          this.applyLayout(index);
        }
        requestAnimationFrame(() => {
          this.pendingTargetIndex = null;
        });
        return true;
      } else {
        this.updatePageCounter();
        return false;
      }
    }
    async scrollToImage(direction) {
      const imgs = this.getImages();
      if (imgs.length === 0) return;
      const { isDualViewEnabled } = this.store.getState();
      const currentIndex = getPrimaryVisibleImageIndex(imgs, window.innerHeight);
      let targetIndex = currentIndex + direction;
      if (targetIndex < 0) targetIndex = 0;
      if (isDualViewEnabled && direction !== 0 && currentIndex !== -1) {
        const currentImg = imgs[currentIndex];
        if (targetIndex < imgs.length) {
          const prospectiveTargetImg = imgs[targetIndex];
          if (currentImg && prospectiveTargetImg && prospectiveTargetImg.parentElement === currentImg.parentElement && prospectiveTargetImg.parentElement?.classList.contains("comic-row-wrapper")) {
            targetIndex += direction;
          }
        }
      }
      if (targetIndex >= imgs.length) {
        if (direction > 0 && !this.store.getState().isMetadataModalOpen) {
          this.store.setState({ isMetadataModalOpen: true });
        }
        return;
      }
      console.log(`[Navigator] scrollToImage: ${direction} (target: ${targetIndex})`);
      const finalIndex = Math.max(0, Math.min(targetIndex, imgs.length - 1));
      const finalTarget = imgs[finalIndex];
      if (finalTarget) {
        this.pendingTargetIndex = finalIndex;
        forceImageLoad(finalTarget);
        if (!finalTarget.complete || finalTarget.naturalHeight === 0) {
          console.log(`[Navigator] Waiting for image load...`);
          this.store.setState({ isLoading: true });
          await waitForImageLoad(finalTarget);
          this.applyLayout(finalIndex);
          this.store.setState({ isLoading: false });
        } else {
          finalTarget.scrollIntoView({ behavior: "smooth", block: "center" });
        }
        requestAnimationFrame(() => {
          this.pendingTargetIndex = null;
        });
      }
    }
    async scrollToEdge(position) {
      const imgs = this.getImages();
      if (imgs.length === 0) return;
      const targetIndex = position === "start" ? 0 : imgs.length - 1;
      const target = imgs[targetIndex];
      this.pendingTargetIndex = targetIndex;
      forceImageLoad(target);
      if (!target.complete || target.naturalHeight === 0) {
        this.store.setState({ isLoading: true });
        await waitForImageLoad(target);
        this.store.setState({ isLoading: false });
      }
      this.applyLayout(targetIndex);
      requestAnimationFrame(() => {
        this.pendingTargetIndex = null;
      });
    }
    applyLayout(forcedIndex) {
      const { enabled, isDualViewEnabled, spreadOffset } = this.store.getState();
      const container = this.adapter.getContainer();
      if (!container) return;
      if (!enabled) {
        revertToOriginal(this.getImages(), container);
        return;
      }
      const imgs = this.getImages();
      const viewportIndex = getPrimaryVisibleImageIndex(imgs, window.innerHeight);
      const currentIndex = this.pendingTargetIndex !== null ? this.pendingTargetIndex : forcedIndex !== void 0 ? forcedIndex : viewportIndex;
      console.log(`[Navigator] applyLayout: current=${currentIndex}, pending=${this.pendingTargetIndex}, forced=${forcedIndex}, viewport=${viewportIndex}`);
      fitImagesToViewport(container, spreadOffset, isDualViewEnabled);
      this.updatePageCounter();
      if (currentIndex !== -1) {
        const targetImg = imgs[currentIndex];
        if (targetImg) {
          requestAnimationFrame(() => {
            console.log(`[Navigator] Executing scrollIntoView for index ${currentIndex}`);
            targetImg.scrollIntoView({ block: "center" });
          });
          preloadImages(imgs, currentIndex);
        }
      }
    }
  }
  const styles = `
  #comic-helper-ui {
    position: fixed;
    bottom: 20px;
    right: 20px;
    z-index: 10000;
    display: flex;
    gap: 8px;
    background-color: rgba(0, 0, 0, 0.7);
    padding: 8px;
    border-radius: 8px;
    box-shadow: 0 2px 10px rgba(0, 0, 0, 0.3);
    cursor: move;
    user-select: none;
    touch-action: none;
    align-items: center;
    white-space: nowrap;
    width: max-content;
    opacity: 0.3;
    transition: opacity 0.3s;
  }

  #comic-helper-ui:hover {
    opacity: 1.0;
  }

  .comic-helper-button {
    cursor: pointer;
    padding: 6px 12px;
    border: none;
    background: #fff;
    color: #333;
    border-radius: 4px;
    font-size: 12px;
    font-weight: bold;
    min-width: 50px;
    transition: background 0.2s;
  }
  .comic-helper-button:hover {
    background: #eee;
  }

  .comic-helper-icon-btn {
    cursor: pointer;
    border: none;
    background: transparent;
    font-size: 16px;
    padding: 0 4px;
    font-weight: bold;
    transition: color 0.2s, opacity 0.2s;
  }
  .comic-helper-icon-btn:hover {
    opacity: 0.8;
  }
  .comic-helper-power-btn.enabled { color: #4CAF50; }
  .comic-helper-power-btn.disabled { color: #888; }

  .comic-helper-counter-wrapper {
    color: #fff;
    font-size: 14px;
    font-weight: bold;
    padding: 0 8px;
    display: flex;
    align-items: center;
    user-select: none;
  }

  .comic-helper-page-input {
    width: 45px;
    background: transparent;
    border: 1px solid transparent;
    color: #fff;
    font-size: 14px;
    font-weight: bold;
    text-align: right;
    padding: 2px;
    outline: none;
    margin: 0;
    transition: border 0.2s, background 0.2s;
  }
  .comic-helper-page-input:focus {
    border: 1px solid #fff;
    background: rgba(255, 255, 255, 0.1);
  }
  /* Hide spin buttons */
  .comic-helper-page-input::-webkit-outer-spin-button,
  .comic-helper-page-input::-webkit-inner-spin-button {
    -webkit-appearance: none;
    margin: 0;
  }
  .comic-helper-page-input[type=number] {
    -moz-appearance: textfield;
  }

  .comic-helper-label {
    display: flex;
    align-items: center;
    color: #fff;
    font-size: 12px;
    cursor: pointer;
    user-select: none;
    margin-right: 8px;
  }
  .comic-helper-label input {
    margin-right: 4px;
  }

  .comic-helper-adjust-btn {
    cursor: pointer;
    padding: 2px 6px;
    border: 1px solid #fff;
    background: transparent;
    color: #fff;
    border-radius: 4px;
    font-size: 10px;
    margin-left: 4px;
    font-weight: normal;
    transition: background 0.2s;
  }
  .comic-helper-adjust-btn:hover {
    background: rgba(255, 255, 255, 0.2);
  }

  /* Metadata Modal Styles */
  .comic-helper-modal-overlay {
    position: fixed;
    top: 0;
    left: 0;
    width: 100vw;
    height: 100vh;
    background: rgba(0, 0, 0, 0.6);
    backdrop-filter: blur(4px);
    z-index: 20000;
    display: flex;
    justify-content: center;
    align-items: center;
  }

  .comic-helper-modal-content {
    background: #1a1a1a;
    color: #eee;
    width: 80%;
    max-width: 800px;
    max-height: 80%;
    padding: 24px;
    border-radius: 12px;
    box-shadow: 0 10px 30px rgba(0, 0, 0, 0.5);
    overflow-y: auto;
    position: relative;
    border: 1px solid #333;
  }

  .comic-helper-modal-close {
    position: absolute;
    top: 16px;
    right: 16px;
    background: transparent;
    border: none;
    color: #888;
    font-size: 24px;
    cursor: pointer;
    line-height: 1;
  }
  .comic-helper-modal-close:hover {
    color: #fff;
  }

  .comic-helper-modal-title {
    margin-top: 0;
    margin-bottom: 20px;
    font-size: 20px;
    border-bottom: 1px solid #333;
    padding-bottom: 10px;
  }

  .comic-helper-section-title {
    font-size: 14px;
    color: #888;
    margin: 20px 0 10px;
    text-transform: uppercase;
    letter-spacing: 1px;
  }

  .comic-helper-tag-list {
    display: flex;
    flex-wrap: wrap;
    gap: 8px;
  }

  .comic-helper-tag-chip {
    background: #333;
    color: #ccc;
    padding: 4px 12px;
    border-radius: 16px;
    font-size: 12px;
    text-decoration: none;
    transition: background 0.2s, color 0.2s;
  }
  .comic-helper-tag-chip:hover {
    background: #444;
    color: #fff;
  }

  /* Tag type color variants */
  .comic-helper-tag-chip--artist {
    background: #5c3d4a;
    color: #f0d0dc;
  }
  .comic-helper-tag-chip--artist:hover {
    background: #7a5060;
    color: #fff;
  }

  .comic-helper-tag-chip--character {
    background: #3d5c4a;
    color: #d0f0dc;
  }
  .comic-helper-tag-chip--character:hover {
    background: #507a60;
    color: #fff;
  }

  .comic-helper-tag-chip--circle {
    background: #3d4a5c;
    color: #d0dcf0;
  }
  .comic-helper-tag-chip--circle:hover {
    background: #50607a;
    color: #fff;
  }

  .comic-helper-tag-chip--fanzine {
    background: #5c4a3d;
    color: #f0dcd0;
  }
  .comic-helper-tag-chip--fanzine:hover {
    background: #7a6050;
    color: #fff;
  }

  .comic-helper-tag-chip--genre {
    background: #4a4a4a;
    color: #d0d0d0;
  }
  .comic-helper-tag-chip--genre:hover {
    background: #606060;
    color: #fff;
  }

  .comic-helper-tag-chip--magazine {
    background: #4a3d5c;
    color: #dcd0f0;
  }
  .comic-helper-tag-chip--magazine:hover {
    background: #60507a;
    color: #fff;
  }

  .comic-helper-tag-chip--parody {
    background: #3d5c5c;
    color: #d0f0f0;
  }
  .comic-helper-tag-chip--parody:hover {
    background: #507a7a;
    color: #fff;
  }

  .comic-helper-related-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 16px;
    margin-top: 10px;
  }

  .comic-helper-related-item {
    text-decoration: none;
    color: #ccc;
    font-size: 11px;
    transition: transform 0.2s;
  }
  .comic-helper-related-item:hover {
    transform: translateY(-4px);
  }

  .comic-helper-related-thumb {
    width: 100%;
    aspect-ratio: 3 / 4;
    object-fit: cover;
    border-radius: 4px;
    background: #222;
    margin-bottom: 6px;
  }

  .comic-helper-related-title {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    line-height: 1.4;
  }

  /* Search Modal Styles */
  .comic-helper-search-container {
    display: flex;
    flex-direction: column;
    gap: 16px;
    margin-top: 20px;
  }

  .comic-helper-search-form {
    display: flex;
    gap: 8px;
    width: 100%;
  }

  .comic-helper-search-input {
    flex: 1;
    background: #222;
    border: 1px solid #444;
    color: #fff;
    padding: 8px 12px;
    border-radius: 4px;
    font-size: 16px;
    outline: none;
    transition: border-color 0.2s;
  }

  .comic-helper-search-input:focus {
    border-color: #4CAF50;
  }

  .comic-helper-search-submit {
    background: #4CAF50;
    color: white;
    border: none;
    padding: 8px 16px;
    border-radius: 4px;
    cursor: pointer;
    font-weight: bold;
    transition: background 0.2s;
  }

  .comic-helper-search-submit:hover {
    background: #45a049;
  }

  /* Search Results Styles */
  .comic-helper-search-results-section {
    margin-top: 4px;
  }

  .comic-helper-search-no-results {
    color: #888;
    font-size: 14px;
    padding: 12px 0;
  }

  .comic-helper-search-result-grid {
    display: grid;
    grid-template-columns: repeat(auto-fill, minmax(140px, 1fr));
    gap: 16px;
    margin-top: 10px;
  }

  .comic-helper-search-result-item {
    text-decoration: none;
    color: #ccc;
    font-size: 11px;
    transition: transform 0.2s;
  }
  .comic-helper-search-result-item:hover {
    transform: translateY(-4px);
  }

  .comic-helper-search-result-thumb {
    width: 100%;
    aspect-ratio: 3 / 4;
    object-fit: cover;
    border-radius: 4px;
    background: #222;
    margin-bottom: 6px;
  }

  .comic-helper-search-result-title {
    display: -webkit-box;
    -webkit-line-clamp: 2;
    -webkit-box-orient: vertical;
    overflow: hidden;
    line-height: 1.4;
  }

  .comic-helper-search-pagination {
    display: flex;
    flex-wrap: wrap;
    gap: 4px;
    margin-top: 20px;
    padding-top: 16px;
    border-top: 1px solid #333;
    justify-content: center;
  }

  .comic-helper-search-page-btn {
    background: #333;
    color: #ccc;
    border: 1px solid #444;
    padding: 4px 8px;
    border-radius: 4px;
    font-size: 12px;
    cursor: pointer;
    min-width: 32px;
    transition: all 0.2s;
  }

  .comic-helper-search-page-btn:hover:not(:disabled) {
    background: #444;
    color: #fff;
    border-color: #666;
  }

  .comic-helper-search-page-btn.active {
    background: #4CAF50;
    color: white;
    border-color: #4CAF50;
    cursor: default;
  }

  .comic-helper-search-page-btn:disabled:not(.active) {
    opacity: 0.5;
    cursor: not-allowed;
  }

  .comic-helper-search-page-btn.type-next,
  .comic-helper-search-page-btn.type-prev {
    font-weight: bold;
    padding: 4px 12px;
  }

  .comic-helper-search-updating {
    margin-left: 8px;
    font-size: 0.8em;
    color: #888;
  }

  /* Help Modal Styles */
  .comic-helper-shortcut-list {
    display: flex;
    flex-direction: column;
    gap: 12px;
  }

  .comic-helper-shortcut-row {
    display: flex;
    justify-content: space-between;
    align-items: center;
    padding: 8px 0;
    border-bottom: 1px solid #222;
  }

  .comic-helper-shortcut-keys {
    display: flex;
    gap: 4px;
    flex-wrap: wrap;
    max-width: 40%;
  }

  .comic-helper-kbd {
    background: #444;
    border: 1px solid #555;
    border-radius: 4px;
    box-shadow: 0 1px 0 rgba(0,0,0,0.2), 0 0 0 2px #333 inset;
    color: #eee;
    display: inline-block;
    font-size: 11px;
    font-family: monospace;
    line-height: 1.4;
    margin: 0 2px;
    padding: 2px 6px;
    white-space: nowrap;
  }

  .comic-helper-shortcut-label {
    color: #eee;
    font-size: 13px;
    font-weight: bold;
    flex: 1;
    margin: 0 12px;
  }

  .comic-helper-shortcut-desc {
    color: #bbb;
    font-size: 13px;
    flex: 1;
  }

  /* Progress Bar Styles */
  #comic-helper-progress-bar {
    position: fixed;
    bottom: 0;
    left: 0;
    width: 100%;
    height: 3px;
    background: rgba(0, 0, 0, 0.3);
    z-index: 10001;
    pointer-events: none;
  }

  .comic-helper-progress-fill {
    height: 100%;
    background: #4CAF50;
    width: 0;
    transition: width 0.2s ease-out;
    box-shadow: 0 0 4px rgba(76, 175, 80, 0.5);
  }

  /* Resume Notification Styles */
  #comic-helper-resume-notification {
    position: fixed;
    bottom: 10px;
    left: 50%;
    transform: translateX(-50%);
    z-index: 10002;
    background: rgba(0, 0, 0, 0.9);
    color: white;
    padding: 12px 16px;
    border-radius: 8px;
    display: flex;
    align-items: center;
    gap: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    font-size: 14px;
  }

  .comic-helper-resume-btn {
    padding: 6px 12px;
    border: none;
    border-radius: 4px;
    cursor: pointer;
    font-size: 13px;
    transition: background-color 0.2s;
  }

  .comic-helper-resume-continue {
    background: #4CAF50;
    color: white;
  }

  .comic-helper-resume-continue:hover {
    background: #45a049;
  }

  .comic-helper-resume-skip {
    background: #666;
    color: white;
  }

  .comic-helper-resume-skip:hover {
    background: #555;
  }

  .comic-helper-resume-close {
    background: transparent;
    color: white;
    padding: 2px 8px;
    font-size: 18px;
  }

  .comic-helper-resume-close:hover {
    background: rgba(255, 255, 255, 0.1);
  }

  /* Loading Indicator Styles */
  #comic-helper-loading {
    position: fixed;
    top: 50%;
    left: 50%;
    transform: translate(-50%, -50%);
    z-index: 10003;
    background: rgba(0, 0, 0, 0.7);
    color: white;
    padding: 16px 24px;
    border-radius: 8px;
    display: flex;
    flex-direction: column;
    align-items: center;
    gap: 12px;
    box-shadow: 0 4px 12px rgba(0, 0, 0, 0.5);
    font-size: 14px;
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s;
  }

  #comic-helper-loading.visible {
    opacity: 1;
  }

  .comic-helper-spinner {
    width: 24px;
    height: 24px;
    border: 3px solid rgba(255, 255, 255, 0.3);
    border-top: 3px solid #fff;
    border-radius: 50%;
    animation: comic-helper-spin 1s linear infinite;
  }

  @keyframes comic-helper-spin {
    0% { transform: rotate(0deg); }
    100% { transform: rotate(360deg); }
  }

  /* Global states */
  html.comic-helper-enabled {
    overflow: hidden !important;
  }
`;
  function injectStyles() {
    const id = "comic-helper-style";
    if (document.getElementById(id)) return;
    const style = document.createElement("style");
    style.id = id;
    style.textContent = styles;
    document.head.appendChild(style);
  }
  function createElement(tag, options = {}, children = []) {
    const el = document.createElement(tag);
    if (options.id) el.id = options.id;
    if (options.className) el.className = options.className;
    if (options.textContent) el.textContent = options.textContent;
    if (options.title) el.title = options.title;
    if (el instanceof HTMLInputElement) {
      if (options.type) el.type = options.type;
      if (options.checked !== void 0) el.checked = options.checked;
    }
    if (options.style) {
      Object.assign(el.style, options.style);
    }
    if (options.attributes) {
      for (const [key, value] of Object.entries(options.attributes)) {
        el.setAttribute(key, String(value));
      }
    }
    if (options.events) {
      for (const [type, listener] of Object.entries(options.events)) {
        el.addEventListener(type, listener);
      }
    }
    children.forEach((child) => {
      if (typeof child === "string") {
        el.appendChild(document.createTextNode(child));
      } else if (child instanceof HTMLElement) {
        el.appendChild(child);
      }
    });
    return el;
  }
  const MESSAGES = {
    en: {
      ui: {
        spread: "Spread",
        offset: "Offset",
        info: "Info",
        help: "Help",
        close: "Close",
        tags: "Tags",
        related: "Related Works",
        version: "Version",
        stable: "stable",
        unstable: "unstable",
        keyboardShortcuts: "Keyboard Shortcuts",
        goFirst: "Go to First",
        goPrev: "Go to Previous",
        goNext: "Go to Next",
        goLast: "Go to Last",
        lucky: "I'm feeling lucky",
        showMetadata: "Show Metadata",
        showHelp: "Show Help",
        showSearch: "Show Search",
        search: "Search",
        searchPlaceholder: "Enter keyword...",
        searchResults: "Search Results",
        searchNoResults: "No results found.",
        searchMoreLink: "Show more â†’",
        shiftOffset: "Shift spread pairing by 1 page (Offset)",
        space: "Space",
        enable: "Enable Comic Viewer Helper",
        disable: "Disable Comic Viewer Helper",
        resume: "Resume",
        resumeNotification: "Resume from page {page}?",
        continueReading: "Continue",
        startFromBeginning: "Start Over"
      },
      shortcuts: {
        nextPage: { label: "Next Page", desc: "Move to next page" },
        prevPage: { label: "Prev Page", desc: "Move to previous page" },
        dualView: { label: "Dual View", desc: "Toggle Dual View" },
        spreadOffset: { label: "Spread Offset", desc: "Toggle Offset (0 â†” 1)", cond: "Dual View only" },
        metadata: { label: "Metadata", desc: "Show metadata" },
        fullscreen: { label: "Fullscreen", desc: "Toggle Fullscreen" },
        help: { label: "Help", desc: "Show this help" },
        search: { label: "Search", desc: "Start search" },
        closeModal: { label: "Close Modal", desc: "Close modal" },
        randomJump: { label: "Random Jump", desc: "Jump to a random related work" }
      }
    },
    ja: {
      ui: {
        spread: "è¦‹é–‹ã",
        offset: "ã‚ªãƒ•ã‚»ãƒƒãƒˆ",
        info: "ä½œå“æƒ…å ±",
        help: "ãƒ˜ãƒ«ãƒ—",
        close: "é–‰ã˜ã‚‹",
        tags: "ã‚¿ã‚°",
        related: "é–¢é€£ä½œå“",
        version: "ãƒãƒ¼ã‚¸ãƒ§ãƒ³",
        stable: "å®‰å®šç‰ˆ",
        unstable: "é–‹ç™ºç‰ˆ",
        keyboardShortcuts: "ã‚­ãƒ¼ãƒœãƒ¼ãƒ‰ã‚·ãƒ§ãƒ¼ãƒˆã‚«ãƒƒãƒˆ",
        goFirst: "æœ€åˆã¸",
        goPrev: "å‰ã¸",
        goNext: "æ¬¡ã¸",
        goLast: "æœ€å¾Œã¸",
        lucky: "ãŠã™ã™ã‚ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰",
        showMetadata: "ä½œå“æƒ…å ±ã‚’è¡¨ç¤º",
        showHelp: "ãƒ˜ãƒ«ãƒ—ã‚’è¡¨ç¤º",
        showSearch: "ã‚µã‚¤ãƒˆå†…æ¤œç´¢ã‚’è¡¨ç¤º",
        search: "æ¤œç´¢",
        searchPlaceholder: "ã‚­ãƒ¼ãƒ¯ãƒ¼ãƒ‰ã‚’å…¥åŠ›...",
        searchResults: "æ¤œç´¢çµæžœ",
        searchNoResults: "çµæžœãŒè¦‹ã¤ã‹ã‚Šã¾ã›ã‚“ã§ã—ãŸã€‚",
        searchMoreLink: "ã‚‚ã£ã¨è¦‹ã‚‹ â†’",
        shiftOffset: "è¦‹é–‹ããƒšã‚¢ã‚’1ãƒšãƒ¼ã‚¸åˆ†ãšã‚‰ã™ï¼ˆã‚ªãƒ•ã‚»ãƒƒãƒˆï¼‰",
        space: "ã‚¹ãƒšãƒ¼ã‚¹",
        enable: "ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’æœ‰åŠ¹ã«ã™ã‚‹",
        disable: "ã‚¹ã‚¯ãƒªãƒ—ãƒˆã‚’ç„¡åŠ¹ã«ã™ã‚‹",
        resume: "ãƒ¬ã‚¸ãƒ¥ãƒ¼ãƒ ",
        resumeNotification: "{page}ãƒšãƒ¼ã‚¸ã‹ã‚‰å†é–‹ã—ã¾ã™ã‹ï¼Ÿ",
        continueReading: "ç¶šãã‹ã‚‰",
        startFromBeginning: "æœ€åˆã‹ã‚‰"
      },
      shortcuts: {
        nextPage: { label: "æ¬¡ãƒšãƒ¼ã‚¸", desc: "æ¬¡ã®ãƒšãƒ¼ã‚¸ã¸ç§»å‹•" },
        prevPage: { label: "å‰ãƒšãƒ¼ã‚¸", desc: "å‰ã®ãƒšãƒ¼ã‚¸ã¸ç§»å‹•" },
        dualView: { label: "è¦‹é–‹ã", desc: "è¦‹é–‹ããƒ¢ãƒ¼ãƒ‰ã®ON/OFF" },
        spreadOffset: { label: "è¦‹é–‹ãã‚ªãƒ•ã‚»ãƒƒãƒˆ", desc: "è¦‹é–‹ãã‚ªãƒ•ã‚»ãƒƒãƒˆã®åˆ‡æ›¿ (0 â†” 1)", cond: "è¦‹é–‹ããƒ¢ãƒ¼ãƒ‰ä¸­ã®ã¿" },
        metadata: { label: "ä½œå“æƒ…å ±", desc: "ä½œå“æƒ…å ±ï¼ˆãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿ï¼‰ã®è¡¨ç¤º" },
        fullscreen: { label: "ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³", desc: "ãƒ•ãƒ«ã‚¹ã‚¯ãƒªãƒ¼ãƒ³ã®åˆ‡ã‚Šæ›¿ãˆ" },
        help: { label: "ãƒ˜ãƒ«ãƒ—", desc: "ã“ã®ãƒ˜ãƒ«ãƒ—ã®è¡¨ç¤º" },
        search: { label: "æ¤œç´¢", desc: "æ¤œç´¢ã®é–‹å§‹" },
        closeModal: { label: "é–‰ã˜ã‚‹", desc: "ãƒ¢ãƒ¼ãƒ€ãƒ«ã‚’é–‰ã˜ã‚‹" },
        randomJump: { label: "ãƒ©ãƒ³ãƒ€ãƒ ã‚¸ãƒ£ãƒ³ãƒ—", desc: "ãŠã™ã™ã‚ï¼ˆãƒ©ãƒ³ãƒ€ãƒ ï¼‰ã¸é·ç§»" }
      }
    }
  };
  const getLanguage = () => {
    const lang = (navigator.language || "en").split("-")[0];
    return lang in MESSAGES ? lang : "en";
  };
  const currentLang = getLanguage();
  function t(path) {
    const keys = path.split(".");
    let result = MESSAGES[currentLang];
    let fallback = MESSAGES["en"];
    for (const key of keys) {
      result = typeof result === "object" && result !== null ? result[key] : void 0;
      fallback = typeof fallback === "object" && fallback !== null ? fallback[key] : void 0;
    }
    const value = result ?? fallback ?? path;
    if (typeof value === "object") {
      return path;
    }
    return String(value);
  }
  function createPowerButton({ isEnabled, onClick }) {
    const el = createElement("button", {
      className: `comic-helper-icon-btn comic-helper-power-btn ${isEnabled ? "enabled" : "disabled"}`,
      title: isEnabled ? t("ui.disable") : t("ui.enable"),
      textContent: "âš¡",
      style: {
        marginRight: isEnabled ? "8px" : "0"
      },
      events: {
        click: (e) => {
          e.preventDefault();
          e.stopPropagation();
          onClick();
        }
      }
    });
    return {
      el,
      update: (enabled) => {
        el.className = `comic-helper-icon-btn comic-helper-power-btn ${enabled ? "enabled" : "disabled"}`;
        el.title = enabled ? t("ui.disable") : t("ui.enable");
        el.style.marginRight = enabled ? "8px" : "0";
      }
    };
  }
  function createPageCounter({ current, total, onJump }) {
    const input = createElement("input", {
      type: "number",
      className: "comic-helper-page-input",
      attributes: { min: 1 },
      events: {
        keydown: (e) => {
          if (e instanceof KeyboardEvent && e.key === "Enter") {
            e.preventDefault();
            onJump(input.value);
          }
        },
        focus: () => {
          input.select();
        }
      }
    });
    input.value = String(current);
    const totalLabel = createElement("span", {
      id: "comic-total-counter",
      textContent: ` / ${total}`
    });
    const el = createElement("span", {
      className: "comic-helper-counter-wrapper"
    }, [input, totalLabel]);
    return {
      el,
      input,
      update: (newCurrent, newTotal) => {
        if (document.activeElement !== input) {
          input.value = String(newCurrent);
        }
        totalLabel.textContent = ` / ${newTotal}`;
      }
    };
  }
  function createSpreadControls({ isDualViewEnabled, onToggle, onAdjust }) {
    const checkbox = createElement("input", {
      type: "checkbox",
      checked: isDualViewEnabled,
      events: {
        change: (e) => {
          const target = e.currentTarget;
          onToggle(target.checked);
          if (typeof target.blur === "function") {
            target.blur();
          }
        }
      }
    });
    const label = createElement("label", {
      className: "comic-helper-label"
    }, [checkbox, t("ui.spread")]);
    const createAdjustBtn = () => createElement("button", {
      className: "comic-helper-adjust-btn",
      textContent: t("ui.offset"),
      title: t("ui.shiftOffset"),
      events: {
        click: (e) => {
          e.preventDefault();
          e.stopPropagation();
          onAdjust();
        }
      }
    });
    let adjustBtn = isDualViewEnabled ? createAdjustBtn() : null;
    const el = createElement("div", {
      style: { display: "flex", alignItems: "center" }
    }, [label]);
    if (adjustBtn) el.appendChild(adjustBtn);
    return {
      el,
      update: (enabled) => {
        checkbox.checked = enabled;
        if (enabled) {
          if (!adjustBtn) {
            adjustBtn = createAdjustBtn();
            el.appendChild(adjustBtn);
          }
        } else {
          if (adjustBtn) {
            adjustBtn.remove();
            adjustBtn = null;
          }
        }
      }
    };
  }
  function createNavigationButtons({
    onFirst,
    onPrev,
    onNext,
    onLast,
    onInfo,
    onHelp,
    onSearch,
    onLucky
  }) {
    const configs = [
      { text: "<<", title: t("ui.goLast"), action: onLast },
      { text: "<", title: t("ui.goNext"), action: onNext },
      { text: "ðŸŽ²", title: t("ui.lucky"), action: onLucky, className: "comic-helper-button comic-helper-icon-btn" },
      { text: ">", title: t("ui.goPrev"), action: onPrev },
      { text: ">>", title: t("ui.goFirst"), action: onFirst },
      { text: "Info", title: t("ui.showMetadata"), action: onInfo },
      { text: "?", title: t("ui.showHelp"), action: onHelp },
      { text: "ðŸ”", title: t("ui.showSearch"), action: onSearch, className: "comic-helper-button comic-helper-icon-btn" }
    ];
    const elements = configs.map((cfg) => createElement("button", {
      className: cfg.className || "comic-helper-button",
      textContent: cfg.text,
      title: cfg.title,
      events: {
        click: (e) => {
          e.preventDefault();
          e.stopPropagation();
          if (cfg.action) cfg.action();
          const target = e.currentTarget;
          if (target && typeof target.blur === "function") {
            target.blur();
          }
        }
      }
    }));
    return {
      elements,
      update: () => {
      }
      // No dynamic state for these buttons yet
    };
  }
  function createMetadataModal({ metadata, onClose }) {
    const { title, tags, relatedWorks } = metadata;
    const closeBtn = createElement("button", {
      className: "comic-helper-modal-close",
      textContent: "Ã—",
      title: t("ui.close"),
      events: {
        click: (e) => {
          e.preventDefault();
          onClose();
        }
      }
    });
    const titleEl = createElement("h2", {
      className: "comic-helper-modal-title",
      textContent: title
    });
    const tagChips = tags.map((tag) => {
      const className = tag.type ? `comic-helper-tag-chip comic-helper-tag-chip--${tag.type}` : "comic-helper-tag-chip";
      return createElement("a", {
        className,
        textContent: tag.text,
        attributes: { href: tag.href, target: "_blank" },
        events: {
          click: (e) => e.stopPropagation()
        }
      });
    });
    const tagSection = createElement("div", {}, [
      createElement("div", { className: "comic-helper-section-title", textContent: t("ui.tags") }),
      createElement("div", { className: "comic-helper-tag-list" }, tagChips)
    ]);
    const relatedItems = relatedWorks.map((work) => {
      const thumb = createElement("img", {
        className: "comic-helper-related-thumb",
        attributes: { src: work.thumb, loading: "lazy" }
      });
      const workTitle = createElement("div", {
        className: "comic-helper-related-title",
        textContent: work.title
      });
      return createElement("a", {
        className: "comic-helper-related-item",
        attributes: { href: work.href, target: "_blank" },
        events: {
          click: (e) => e.stopPropagation()
        }
      }, [thumb, workTitle]);
    });
    const relatedSection = createElement("div", {}, [
      createElement("div", { className: "comic-helper-section-title", textContent: t("ui.related") }),
      createElement("div", { className: "comic-helper-related-grid" }, relatedItems)
    ]);
    const versionTag = createElement("div", {
      className: "comic-helper-modal-version",
      style: {
        fontSize: "11px",
        color: "#888",
        marginTop: "15px",
        textAlign: "right",
        borderTop: "1px solid #eee",
        paddingTop: "5px"
      },
      textContent: `${t("ui.version")}: v${"1.3.0-unstable.44aed67"} (${t("ui.unstable")})`
    });
    const content = createElement("div", {
      className: "comic-helper-modal-content",
      events: {
        click: (e) => e.stopPropagation()
      }
    }, [closeBtn, titleEl, tagSection, relatedSection, versionTag]);
    const overlay = createElement("div", {
      className: "comic-helper-modal-overlay",
      events: {
        click: (e) => {
          e.preventDefault();
          onClose();
        }
      }
    }, [content]);
    return {
      el: overlay,
      update: () => {
      }
      // No dynamic update needed once opened
    };
  }
  const NAV_ARROW_KEYS = {
    next: "ArrowLeft",
    prev: "ArrowRight"
  };
  const SHORTCUTS = [
    {
      id: "nextPage",
      label: t("shortcuts.nextPage.label"),
      keys: ["j", "ArrowDown", "PageDown", NAV_ARROW_KEYS.next, "Space"],
      description: t("shortcuts.nextPage.desc")
    },
    {
      id: "prevPage",
      label: t("shortcuts.prevPage.label"),
      keys: ["k", "ArrowUp", "PageUp", NAV_ARROW_KEYS.prev, "Shift+Space"],
      description: t("shortcuts.prevPage.desc")
    },
    {
      id: "dualView",
      label: t("shortcuts.dualView.label"),
      keys: ["d"],
      description: t("shortcuts.dualView.desc")
    },
    {
      id: "spreadOffset",
      label: t("shortcuts.spreadOffset.label"),
      keys: ["o"],
      description: t("shortcuts.spreadOffset.desc"),
      condition: t("shortcuts.spreadOffset.cond")
    },
    {
      id: "metadata",
      label: t("shortcuts.metadata.label"),
      keys: ["i"],
      description: t("shortcuts.metadata.desc")
    },
    {
      id: "fullscreen",
      label: t("shortcuts.fullscreen.label"),
      keys: ["f"],
      description: t("shortcuts.fullscreen.desc")
    },
    {
      id: "help",
      label: t("shortcuts.help.label"),
      keys: ["?"],
      description: t("shortcuts.help.desc")
    },
    {
      id: "search",
      label: t("shortcuts.search.label"),
      keys: ["/"],
      description: t("shortcuts.search.desc")
    },
    {
      id: "randomJump",
      label: t("shortcuts.randomJump.label"),
      keys: ["p"],
      description: t("shortcuts.randomJump.desc")
    },
    {
      id: "closeModal",
      label: t("shortcuts.closeModal.label"),
      keys: ["Escape"],
      description: t("shortcuts.closeModal.desc")
    }
  ];
  function createHelpModal({ onClose }) {
    const closeBtn = createElement("button", {
      className: "comic-helper-modal-close",
      textContent: "Ã—",
      title: t("ui.close"),
      events: {
        click: (e) => {
          e.preventDefault();
          onClose();
        }
      }
    });
    const titleEl = createElement("h2", {
      className: "comic-helper-modal-title",
      textContent: t("ui.keyboardShortcuts")
    });
    const shortcutRows = SHORTCUTS.map((sc) => {
      const keyLabels = sc.keys.map((k) => {
        let label = k;
        if (k === " ") label = t("ui.space");
        else if (k.includes("Arrow")) {
          if (k === "ArrowLeft") label = "â†";
          if (k === "ArrowRight") label = "â†’";
          if (k === "ArrowUp") label = "â†‘";
          if (k === "ArrowDown") label = "â†“";
        }
        return createElement("kbd", { className: "comic-helper-kbd", textContent: label });
      });
      const keyContainer = createElement("div", { className: "comic-helper-shortcut-keys" }, keyLabels);
      const labelEl = createElement("div", { className: "comic-helper-shortcut-label", textContent: sc.label });
      const descText = sc.condition ? `${sc.description} (${sc.condition})` : sc.description;
      const descEl = createElement("div", { className: "comic-helper-shortcut-desc", textContent: descText });
      return createElement("div", { className: "comic-helper-shortcut-row" }, [keyContainer, labelEl, descEl]);
    });
    const shortcutList = createElement("div", { className: "comic-helper-shortcut-list" }, shortcutRows);
    const content = createElement("div", {
      className: "comic-helper-modal-content",
      events: {
        click: (e) => e.stopPropagation()
      }
    }, [closeBtn, titleEl, shortcutList]);
    const overlay = createElement("div", {
      className: "comic-helper-modal-overlay",
      events: {
        click: (e) => {
          e.preventDefault();
          onClose();
        }
      }
    }, [content]);
    return {
      el: overlay,
      update: () => {
      }
    };
  }
  function createResultsSection(searchResults, onPageChange) {
    const section = createElement("div", {
      className: "comic-helper-search-results-section"
    });
    if (!searchResults) return section;
    const { results, totalCount, pagination } = searchResults;
    const header = createElement("div", {
      className: "comic-helper-section-title"
    });
    header.textContent = totalCount ? `${t("ui.searchResults")} ${totalCount}` : t("ui.searchResults");
    section.appendChild(header);
    if (results.length === 0) {
      section.appendChild(createElement("div", {
        className: "comic-helper-search-no-results",
        textContent: t("ui.searchNoResults")
      }));
      return section;
    }
    const grid = createElement("div", {
      className: "comic-helper-search-result-grid"
    });
    results.forEach((item) => {
      const thumb = createElement("img", {
        className: "comic-helper-search-result-thumb",
        attributes: { src: item.thumb, loading: "lazy" }
      });
      const title = createElement("div", {
        className: "comic-helper-search-result-title",
        textContent: item.title
      });
      const link = createElement("a", {
        className: "comic-helper-search-result-item",
        attributes: { href: item.href, target: "_blank" },
        events: { click: (e) => e.stopPropagation() }
      }, [thumb, title]);
      grid.appendChild(link);
    });
    section.appendChild(grid);
    if (pagination && pagination.length > 0) {
      const nav = createElement("div", {
        className: "comic-helper-search-pagination"
      });
      pagination.forEach((item) => {
        const label = item.type === "next" ? t("ui.goNext") : item.type === "prev" ? t("ui.goPrev") : item.label;
        const btn = createElement("button", {
          className: `comic-helper-search-page-btn${item.isCurrent ? " active" : ""} type-${item.type}`,
          textContent: item.label,
          attributes: {
            title: label,
            ...!item.url || item.isCurrent ? { disabled: "true" } : {}
          },
          events: {
            click: (e) => {
              e.preventDefault();
              if (item.url) onPageChange(item.url);
            }
          }
        });
        nav.appendChild(btn);
      });
      section.appendChild(nav);
    }
    return section;
  }
  function createSearchModal({ onSearch, onPageChange, onClose, searchResults, searchQuery }) {
    const input = createElement("input", {
      className: "comic-helper-search-input",
      attributes: {
        type: "text",
        placeholder: t("ui.searchPlaceholder"),
        autofocus: "true",
        value: searchQuery || ""
      }
    });
    const submitBtn = createElement("button", {
      className: "comic-helper-search-submit",
      textContent: t("ui.search"),
      attributes: {
        type: "submit"
      }
    });
    const handleSubmit = () => {
      const query = input.value.trim();
      if (query) onSearch(query);
    };
    const form = createElement("form", {
      className: "comic-helper-search-form",
      events: {
        submit: (e) => {
          e.preventDefault();
          handleSubmit();
        }
      }
    }, [input, submitBtn]);
    let resultsSection = createResultsSection(searchResults, onPageChange);
    const container = createElement("div", {
      className: "comic-helper-search-container"
    }, [form, resultsSection]);
    const closeBtn = createElement("button", {
      className: "comic-helper-modal-close",
      textContent: "Ã—",
      title: t("ui.close"),
      events: {
        click: (e) => {
          e.preventDefault();
          onClose();
        }
      }
    });
    const title = createElement("h2", {
      className: "comic-helper-modal-title",
      textContent: t("ui.search")
    });
    const updatingIndicator = createElement("span", {
      className: "comic-helper-search-updating",
      textContent: "...",
      style: { display: "none" }
    });
    title.appendChild(updatingIndicator);
    const content = createElement("div", {
      className: "comic-helper-modal-content",
      events: {
        click: (e) => e.stopPropagation()
      }
    }, [closeBtn, title, container]);
    content.addEventListener("wheel", (e) => e.stopPropagation(), { passive: true });
    const overlay = createElement("div", {
      className: "comic-helper-modal-overlay",
      events: {
        click: onClose
      }
    }, [content]);
    overlay.addEventListener("wheel", (e) => {
      e.preventDefault();
      e.stopPropagation();
    }, { passive: false });
    setTimeout(() => input.focus(), 50);
    return {
      el: overlay,
      input,
      updateResults: (newResults) => {
        const newSection = createResultsSection(newResults, onPageChange);
        container.replaceChild(newSection, resultsSection);
        resultsSection = newSection;
        content.scrollTop = 0;
      },
      setUpdating: (updating) => {
        updatingIndicator.style.display = updating ? "inline" : "none";
      }
    };
  }
  function createProgressBar() {
    const bar = createElement("div", { className: "comic-helper-progress-fill" });
    const el = createElement("div", { id: "comic-helper-progress-bar" }, [bar]);
    const update = (current, total) => {
      if (total <= 0) return;
      const percentage = Math.min((current + 1) / total * 100, 100);
      bar.style.width = `${percentage}%`;
    };
    return { el, update };
  }
  function createResumeNotification({ savedIndex, onResume, onSkip }) {
    let timeoutId = null;
    let scrollHandler = null;
    const message = t("ui.resumeNotification").replace("{page}", String(savedIndex + 1));
    const continueBtn = createElement("button", {
      className: "comic-helper-resume-btn comic-helper-resume-continue",
      textContent: t("ui.continueReading"),
      events: {
        click: () => {
          onResume();
          cleanup();
        }
      }
    });
    const skipBtn = createElement("button", {
      className: "comic-helper-resume-btn comic-helper-resume-skip",
      textContent: t("ui.startFromBeginning"),
      events: {
        click: () => {
          cleanup();
        }
      }
    });
    const closeBtn = createElement("button", {
      className: "comic-helper-resume-btn comic-helper-resume-close",
      textContent: "Ã—",
      events: {
        click: () => cleanup()
      }
    });
    const el = createElement("div", {
      id: "comic-helper-resume-notification",
      className: "comic-helper-resume-notification"
    }, [
      createElement("span", { textContent: message }),
      continueBtn,
      skipBtn,
      closeBtn
    ]);
    const cleanup = () => {
      if (timeoutId) clearTimeout(timeoutId);
      if (scrollHandler) window.removeEventListener("scroll", scrollHandler);
      el.remove();
    };
    timeoutId = window.setTimeout(cleanup, 15e3);
    window.setTimeout(() => {
      scrollHandler = () => cleanup();
      window.addEventListener("scroll", scrollHandler, { once: true });
    }, 1e3);
    return { el };
  }
  function createLoadingIndicator({ isLoading }) {
    const el = createElement("div", { id: "comic-helper-loading" });
    const spinner = createElement("div", { className: "comic-helper-spinner" });
    const text = createElement("span", { textContent: "Loading..." });
    el.appendChild(spinner);
    el.appendChild(text);
    if (isLoading) {
      el.classList.add("visible");
    }
    const update = (newLoading) => {
      if (newLoading) {
        el.classList.add("visible");
      } else {
        el.classList.remove("visible");
      }
    };
    return { el, update };
  }
  class Draggable {
    element;
    onDragEnd;
    isDragging;
    dragStartX;
    dragStartY;
    initialTop;
    initialLeft;
    constructor(element, options = {}) {
      this.element = element;
      this.onDragEnd = options.onDragEnd || (() => {
      });
      this.isDragging = false;
      this.dragStartX = 0;
      this.dragStartY = 0;
      this.initialTop = 0;
      this.initialLeft = 0;
      this._onMouseDown = this._onMouseDown.bind(this);
      this._onMouseMove = this._onMouseMove.bind(this);
      this._onMouseUp = this._onMouseUp.bind(this);
      this.element.addEventListener("mousedown", this._onMouseDown);
    }
    _onMouseDown(e) {
      if (e.button !== 0 || !(e.target instanceof HTMLElement)) return;
      if (e.target.tagName === "BUTTON" || e.target.tagName === "INPUT") return;
      this.isDragging = true;
      const rect = this.element.getBoundingClientRect();
      this.initialTop = rect.top;
      this.initialLeft = rect.left;
      this.dragStartX = e.clientX;
      this.dragStartY = e.clientY;
      Object.assign(this.element.style, {
        top: `${this.initialTop}px`,
        left: `${this.initialLeft}px`,
        bottom: "auto",
        right: "auto"
      });
      document.addEventListener("mousemove", this._onMouseMove);
      document.addEventListener("mouseup", this._onMouseUp);
      e.preventDefault();
    }
    /**
     * Clamp the element's position to keep it within the viewport
     * @returns {{top: number, left: number}} The clamped position
     */
    clampToViewport() {
      const rect = this.element.getBoundingClientRect();
      const vw = window.innerWidth;
      const vh = window.innerHeight;
      const padding = 10;
      let top = rect.top;
      let left = rect.left;
      const maxTop = vh - rect.height - padding;
      const maxLeft = vw - rect.width - padding;
      top = Math.max(padding, Math.min(top, maxTop));
      left = Math.max(padding, Math.min(left, maxLeft));
      Object.assign(this.element.style, {
        top: `${top}px`,
        left: `${left}px`,
        bottom: "auto",
        right: "auto"
      });
      return { top, left };
    }
    _onMouseMove(e) {
      if (!this.isDragging) return;
      const deltaX = e.clientX - this.dragStartX;
      const deltaY = e.clientY - this.dragStartY;
      this.element.style.top = `${this.initialTop + deltaY}px`;
      this.element.style.left = `${this.initialLeft + deltaX}px`;
      this.clampToViewport();
    }
    _onMouseUp() {
      if (!this.isDragging) return;
      this.isDragging = false;
      document.removeEventListener("mousemove", this._onMouseMove);
      document.removeEventListener("mouseup", this._onMouseUp);
      const { top, left } = this.clampToViewport();
      this.onDragEnd(top, left);
    }
    destroy() {
      this.element.removeEventListener("mousedown", this._onMouseDown);
      document.removeEventListener("mousemove", this._onMouseMove);
      document.removeEventListener("mouseup", this._onMouseUp);
    }
  }
  const SEARCH_TTL = 60 * 60 * 1e3;
  class UIManager {
    adapter;
    store;
    navigator;
    // Component references
    powerComp;
    counterComp;
    spreadComp;
    progressComp;
    loadingComp;
    draggable;
    modalEl;
    helpModalEl;
    searchModalComp;
    constructor(adapter, store, navigator2) {
      this.adapter = adapter;
      this.store = store;
      this.navigator = navigator2;
      this.powerComp = null;
      this.counterComp = null;
      this.spreadComp = null;
      this.progressComp = null;
      this.loadingComp = null;
      this.draggable = null;
      this.modalEl = null;
      this.helpModalEl = null;
      this.searchModalComp = null;
      this.updateUI = this.updateUI.bind(this);
      this.init = this.init.bind(this);
    }
    init() {
      injectStyles();
      this.updateUI();
      this.store.subscribe(this.updateUI);
      window.addEventListener("resize", () => {
        if (this.draggable) {
          const { top, left } = this.draggable.clampToViewport();
          this.store.setState({ guiPos: { top, left } });
        }
      });
    }
    updateUI() {
      const state = this.store.getState();
      const { enabled, isDualViewEnabled, guiPos, currentVisibleIndex, isLoading } = state;
      let container = document.getElementById("comic-helper-ui");
      if (!container) {
        container = createElement("div", { id: "comic-helper-ui" });
        if (guiPos) {
          Object.assign(container.style, {
            top: `${guiPos.top}px`,
            left: `${guiPos.left}px`,
            bottom: "auto",
            right: "auto"
          });
        }
        this.draggable = new Draggable(container, {
          onDragEnd: (top, left) => this.store.setState({ guiPos: { top, left } })
        });
        document.body.appendChild(container);
      }
      if (!this.powerComp) {
        this.powerComp = createPowerButton({
          isEnabled: enabled,
          onClick: () => {
            const newState = !this.store.getState().enabled;
            this.store.setState({ enabled: newState });
          }
        });
        container.appendChild(this.powerComp.el);
      }
      const imgs = this.navigator.getImages();
      if (!this.counterComp) {
        this.counterComp = createPageCounter({
          current: currentVisibleIndex + 1,
          total: imgs.length,
          onJump: (val) => {
            (async () => {
              const success = await this.navigator.jumpToPage(val);
              if (this.counterComp) {
                this.counterComp.input.blur();
                if (!success) {
                  this.counterComp.input.style.backgroundColor = "rgba(255, 0, 0, 0.3)";
                  setTimeout(() => {
                    if (this.counterComp) this.counterComp.input.style.backgroundColor = "";
                  }, 500);
                }
              }
            })();
          }
        });
        container.appendChild(this.counterComp.el);
      }
      if (!this.spreadComp) {
        this.spreadComp = createSpreadControls({
          isDualViewEnabled,
          onToggle: (val) => this.store.setState({ isDualViewEnabled: val }),
          onAdjust: () => {
            const { spreadOffset } = this.store.getState();
            this.store.setState({ spreadOffset: spreadOffset === 0 ? 1 : 0 });
          }
        });
        container.appendChild(this.spreadComp.el);
      }
      if (!this.progressComp) {
        this.progressComp = createProgressBar();
        document.body.appendChild(this.progressComp.el);
      }
      if (!this.loadingComp) {
        this.loadingComp = createLoadingIndicator({ isLoading });
        document.body.appendChild(this.loadingComp.el);
      }
      if (container.querySelectorAll(".comic-helper-button").length === 0) {
        const { metadata: metadata2 } = state;
        const navBtns = createNavigationButtons({
          onFirst: () => {
            void this.navigator.scrollToEdge("start");
          },
          onPrev: () => {
            void this.navigator.scrollToImage(-1);
          },
          onNext: () => {
            void this.navigator.scrollToImage(1);
          },
          onLast: () => {
            void this.navigator.scrollToEdge("end");
          },
          onInfo: () => this.store.setState({ isMetadataModalOpen: true }),
          onHelp: () => this.store.setState({ isHelpModalOpen: true }),
          onSearch: () => this.store.setState({ isSearchModalOpen: true }),
          onLucky: () => {
            jumpToRandomWork(metadata2);
          }
        });
        navBtns.elements.forEach((btn) => container?.appendChild(btn));
      }
      const { isMetadataModalOpen, isHelpModalOpen, isSearchModalOpen, metadata } = state;
      this.helpModalEl = this._manageModal(
        isHelpModalOpen,
        this.helpModalEl,
        () => createHelpModal({
          onClose: () => this.store.setState({ isHelpModalOpen: false })
        })
      );
      if (isSearchModalOpen) {
        if (!this.searchModalComp) {
          const { searchResults, searchQuery, searchCache } = state;
          this.searchModalComp = createSearchModal({
            searchResults,
            searchQuery,
            onSearch: (query) => this._performSearch(query),
            onPageChange: (url) => this._performSearch(url),
            onClose: () => {
              this.store.setState({ isSearchModalOpen: false });
            }
          });
          document.body.appendChild(this.searchModalComp.el);
          if (searchCache && searchCache.query === searchQuery) {
            this.store.setState({ searchResults: searchCache.results });
            this.searchModalComp.updateResults(searchCache.results);
            if (Date.now() - searchCache.fetchedAt > SEARCH_TTL) {
              void this._performSearch(searchQuery, true);
            }
          } else if (searchQuery) {
            void this._performSearch(searchQuery);
          }
        }
      } else {
        if (this.searchModalComp) {
          this.searchModalComp.el.remove();
          this.searchModalComp = null;
        }
      }
      this.modalEl = this._manageModal(
        isMetadataModalOpen,
        this.modalEl,
        () => createMetadataModal({
          metadata,
          onClose: () => this.store.setState({ isMetadataModalOpen: false })
        })
      );
      this.powerComp.update(enabled);
      this.loadingComp.update(isLoading);
      document.documentElement.classList.toggle("comic-helper-enabled", enabled);
      if (!enabled) {
        container.style.padding = "4px 8px";
        this.counterComp.el.style.display = "none";
        this.spreadComp.el.style.display = "none";
        if (this.progressComp) this.progressComp.el.style.display = "none";
        container.querySelectorAll(".comic-helper-button").forEach((btn) => {
          btn.style.display = "none";
        });
        return;
      }
      container.style.padding = "8px";
      this.counterComp.el.style.display = "flex";
      this.spreadComp.el.style.display = "flex";
      if (this.progressComp) {
        this.progressComp.el.style.display = "block";
        this.progressComp.update(currentVisibleIndex, imgs.length);
      }
      container.querySelectorAll(".comic-helper-button").forEach((btn) => {
        btn.style.display = "inline-block";
      });
      this.counterComp.update(currentVisibleIndex + 1, imgs.length);
      this.spreadComp.update(isDualViewEnabled);
    }
    /**
     * Show resume notification
     */
    showResumeNotification(savedIndex) {
      const notification = createResumeNotification({
        savedIndex,
        onResume: () => {
          this.navigator.jumpToPage(savedIndex + 1);
        },
        onSkip: () => {
        }
      });
      document.body.appendChild(notification.el);
    }
    /**
     * Private helper to manage modal lifecycle (creation and destruction)
     */
    _manageModal(isOpen, modalEl, createFn) {
      if (isOpen) {
        if (!modalEl) {
          const newModal = createFn();
          modalEl = newModal.el;
          document.body.appendChild(modalEl);
        }
      } else {
        if (modalEl) {
          modalEl.remove();
          modalEl = null;
        }
      }
      return modalEl;
    }
    /**
     * Perform search and update store/cache
     */
    async _performSearch(queryOrUrl, silent = false) {
      if (!this.adapter.getSearchUrl || !this.adapter.parseSearchResults) return;
      let url;
      let query;
      const isUrl = queryOrUrl.startsWith("http") || queryOrUrl.startsWith("/");
      if (isUrl) {
        url = queryOrUrl;
        query = this.store.getState().searchQuery;
      } else {
        query = queryOrUrl;
        url = this.adapter.getSearchUrl(query);
        if (!silent) {
          this.store.setState({ searchQuery: query });
        }
      }
      if (silent || isUrl) {
        this.searchModalComp?.setUpdating(true);
      }
      try {
        const res = await fetch(url);
        if (!res.ok) throw new Error(`HTTP ${res.status}`);
        const html = await res.text();
        const doc = new DOMParser().parseFromString(html, "text/html");
        const results = this.adapter.parseSearchResults(doc);
        this.store.setState({
          searchResults: results,
          searchCache: {
            query,
            results,
            fetchedAt: Date.now()
          }
        });
        this.searchModalComp?.updateResults(results);
      } catch (error) {
        console.error("Failed to fetch search results:", error);
      } finally {
        this.searchModalComp?.setUpdating(false);
      }
    }
  }
  const CLICK_THRESHOLD_PX = 5;
  class InputManager {
    store;
    navigator;
    lastWheelTime;
    WHEEL_THROTTLE_MS = 500;
    WHEEL_THRESHOLD = 1;
    resizeReq;
    scrollReq;
    mouseDownPos;
    mouseDownTarget;
    constructor(store, navigator2) {
      this.store = store;
      this.navigator = navigator2;
      this.lastWheelTime = 0;
      this.resizeReq = void 0;
      this.scrollReq = void 0;
      this.mouseDownPos = null;
      this.mouseDownTarget = null;
      this.handleWheel = this.handleWheel.bind(this);
      this.onKeyDown = this.onKeyDown.bind(this);
      this.handleResize = this.handleResize.bind(this);
      this.handleScroll = this.handleScroll.bind(this);
      this.onMouseDown = this.onMouseDown.bind(this);
      this.onMouseUp = this.onMouseUp.bind(this);
    }
    init() {
      window.addEventListener("wheel", this.handleWheel, { passive: false });
      document.addEventListener("keydown", this.onKeyDown, true);
      document.addEventListener("mousedown", this.onMouseDown);
      document.addEventListener("mouseup", this.onMouseUp);
      window.addEventListener("resize", this.handleResize);
      window.addEventListener("scroll", this.handleScroll);
    }
    isInputField(target) {
      if (!(target instanceof HTMLElement)) return false;
      return target instanceof HTMLInputElement || target instanceof HTMLTextAreaElement || target instanceof HTMLSelectElement || !!target.isContentEditable;
    }
    handleWheel(e) {
      const { enabled, isDualViewEnabled, currentVisibleIndex, isMetadataModalOpen, isHelpModalOpen } = this.store.getState();
      if (!enabled) return;
      if (isMetadataModalOpen || isHelpModalOpen) {
        const modalContent = document.querySelector(".comic-helper-modal-content");
        if (modalContent && modalContent.contains(e.target)) {
          return;
        }
        e.preventDefault();
        return;
      }
      e.preventDefault();
      const now = Date.now();
      if (now - this.lastWheelTime < this.WHEEL_THROTTLE_MS) return;
      const direction = getNavigationDirection(e, this.WHEEL_THRESHOLD);
      if (direction === "none") return;
      const imgs = this.navigator.getImages();
      if (imgs.length === 0) return;
      this.lastWheelTime = now;
      const step = isDualViewEnabled ? 2 : 1;
      if (direction === "next" && currentVisibleIndex + step >= imgs.length) {
        if (!isMetadataModalOpen) {
          this.store.setState({ isMetadataModalOpen: true });
        }
        return;
      }
      const nextIndex = direction === "next" ? currentVisibleIndex + step : Math.max(currentVisibleIndex - step, 0);
      this.navigator.jumpToPage(nextIndex + 1);
    }
    onKeyDown(e) {
      if (this.isInputField(e.target) || e.ctrlKey || e.metaKey || e.altKey) return;
      const { enabled, isDualViewEnabled, isMetadataModalOpen, isHelpModalOpen, isSearchModalOpen } = this.store.getState();
      if (e.key === "Escape") {
        if (isMetadataModalOpen || isHelpModalOpen || isSearchModalOpen) {
          e.preventDefault();
          this.store.setState({
            isMetadataModalOpen: false,
            isHelpModalOpen: false,
            isSearchModalOpen: false
          });
          return;
        }
      }
      const isKey = (id) => {
        const sc = SHORTCUTS.find((s) => s.id === id);
        if (!sc) return false;
        return sc.keys.some((k) => {
          if (k.startsWith("Shift+")) {
            const baseKey = k.replace("Shift+", "");
            return e.shiftKey && e.key === (baseKey === "Space" ? " " : baseKey);
          }
          return !e.shiftKey && e.key === (k === "Space" ? " " : k);
        });
      };
      if (isKey("help") && isHelpModalOpen) {
        e.preventDefault();
        this.store.setState({ isHelpModalOpen: false });
        return;
      }
      if (isKey("search")) {
        e.preventDefault();
        this.store.setState({ isSearchModalOpen: !isSearchModalOpen });
        return;
      }
      if (isMetadataModalOpen || isHelpModalOpen || isSearchModalOpen || !enabled) return;
      if (isKey("nextPage")) {
        e.preventDefault();
        this.navigator.scrollToImage(1);
      } else if (isKey("prevPage")) {
        e.preventDefault();
        this.navigator.scrollToImage(-1);
      } else if (isKey("dualView")) {
        e.preventDefault();
        this.store.setState({ isDualViewEnabled: !isDualViewEnabled });
      } else if (isKey("spreadOffset") && isDualViewEnabled) {
        e.preventDefault();
        const { spreadOffset } = this.store.getState();
        this.store.setState({ spreadOffset: spreadOffset === 0 ? 1 : 0 });
      } else if (isKey("metadata")) {
        e.preventDefault();
        this.store.setState({ isMetadataModalOpen: !isMetadataModalOpen });
      } else if (isKey("help")) {
        e.preventDefault();
        this.store.setState({ isHelpModalOpen: !isHelpModalOpen });
      } else if (isKey("fullscreen")) {
        e.preventDefault();
        if (!document.documentElement.requestFullscreen) return;
        if (document.fullscreenElement) {
          document.exitFullscreen().catch(() => {
          });
        } else {
          document.documentElement.requestFullscreen().catch(() => {
          });
        }
      } else if (isKey("randomJump")) {
        e.preventDefault();
        const { metadata } = this.store.getState();
        jumpToRandomWork(metadata);
      }
    }
    handleResize() {
      const { enabled, currentVisibleIndex } = this.store.getState();
      if (!enabled) return;
      if (this.resizeReq) cancelAnimationFrame(this.resizeReq);
      this.resizeReq = requestAnimationFrame(() => this.navigator.applyLayout(currentVisibleIndex));
    }
    handleScroll() {
      if (!this.store.getState().enabled) return;
      if (this.scrollReq) cancelAnimationFrame(this.scrollReq);
      this.scrollReq = requestAnimationFrame(() => this.navigator.updatePageCounter());
    }
    onMouseDown(e) {
      if (!(e.target instanceof HTMLImageElement)) return;
      this.mouseDownPos = { x: e.clientX, y: e.clientY };
      this.mouseDownTarget = e.target;
    }
    onMouseUp(e) {
      const target = this.mouseDownTarget;
      const startPos = this.mouseDownPos;
      this.mouseDownTarget = null;
      this.mouseDownPos = null;
      if (!target || !startPos) return;
      if (!(e.target instanceof HTMLImageElement) || e.target !== target) return;
      const dx = e.clientX - startPos.x;
      const dy = e.clientY - startPos.y;
      if (Math.sqrt(dx * dx + dy * dy) >= CLICK_THRESHOLD_PX) return;
      const { enabled, isMetadataModalOpen, isHelpModalOpen } = this.store.getState();
      if (!enabled || isMetadataModalOpen || isHelpModalOpen) return;
      const direction = getClickNavigationDirection(target);
      this.navigator.scrollToImage(direction === "next" ? 1 : -1);
    }
  }
  class ResumeManager {
    store;
    storageKey = "comic-viewer-helper-resume-data";
    constructor(store) {
      this.store = store;
    }
    isEnabled() {
      return true;
    }
    savePosition(url, pageIndex) {
      const data = this._loadData();
      data[url] = { pageIndex };
      localStorage.setItem(this.storageKey, JSON.stringify(data));
    }
    loadPosition(url) {
      const data = this._loadData();
      return data[url]?.pageIndex ?? null;
    }
    _loadData() {
      try {
        return JSON.parse(localStorage.getItem(this.storageKey) || "{}");
      } catch {
        return {};
      }
    }
    /**
     * Clear all saved positions
     */
    clearAll() {
      localStorage.removeItem(this.storageKey);
    }
  }
  class PopUnderBlocker {
    store;
    constructor(store) {
      this.store = store;
      this.handleClick = this.handleClick.bind(this);
    }
    init() {
      document.addEventListener("click", this.handleClick, true);
    }
    handleClick(e) {
      if (!this.store.getState().enabled) return;
      const target = e.target;
      const link = target.closest("a");
      if (!(link instanceof HTMLAnchorElement)) return;
      if (!link.hasAttribute("href")) return;
      if (e.ctrlKey || e.metaKey) return;
      if (link.href.startsWith("javascript:")) return;
      const isOwnLink = link.className.includes("comic-helper-");
      if (link.target === "_blank" && !isOwnLink) return;
      e.stopImmediatePropagation();
      e.preventDefault();
      window.location.href = link.href;
    }
  }
  class App {
    store;
    adapter;
    navigator;
    uiManager;
    inputManager;
    resumeManager;
    popUnderBlocker;
    constructor() {
      this.store = new Store();
      const adapters = [DefaultAdapter];
      this.adapter = adapters.find((a) => a.match(window.location.href)) || DefaultAdapter;
      this.navigator = new Navigator(this.adapter, this.store);
      this.uiManager = new UIManager(this.adapter, this.store, this.navigator);
      this.inputManager = new InputManager(this.store, this.navigator);
      this.resumeManager = new ResumeManager(this.store);
      this.popUnderBlocker = new PopUnderBlocker(this.store);
      this.init = this.init.bind(this);
    }
    init() {
      const container = this.adapter.getContainer();
      if (!container) return;
      const metadata = this.adapter.getMetadata?.() ?? { title: "Unknown Title", tags: [], relatedWorks: [] };
      this.store.setState({ metadata });
      this.navigator.init();
      this.uiManager.init();
      this.inputManager.init();
      this.popUnderBlocker.init();
      if (this.resumeManager.isEnabled()) {
        const workKey = window.location.origin + window.location.pathname;
        const savedIndex = this.resumeManager.loadPosition(workKey);
        if (savedIndex !== null && savedIndex > 0) {
          this.uiManager.showResumeNotification(savedIndex);
        }
      }
      window.addEventListener("beforeunload", () => {
        if (this.resumeManager.isEnabled()) {
          const workKey = window.location.origin + window.location.pathname;
          const currentIndex = this.store.getState().currentVisibleIndex;
          this.resumeManager.savePosition(workKey, currentIndex);
        }
      });
    }
  }
  const app = new App();
  if (document.readyState === "loading") {
    document.addEventListener("DOMContentLoaded", app.init);
  } else {
    app.init();
  }
})();
