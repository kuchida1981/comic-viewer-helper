## Context

現在の検索機能は、前回の検索クエリのみを記憶しており、以前に使用した複数のクエリを簡単に呼び出す手段がありません。ユーザーは同じキーワード（特に複数のタグを組み合わせた複雑なもの）を再入力する必要があります。

## Goals / Non-Goals

**Goals:**
- 直近の検索クエリを最大3件まで保存し、UIから再利用可能にする。
- クエリの順序が異なる場合でも同一とみなす「正規化」による重複排除を実現する。
- 履歴データの永続化（ホスト名別）。
- 実装がシンプルで、件数制限の変更が容易な構造にする。

**Non-Goals:**
- 履歴の削除機能の実装（今回は「最新3件の自動入れ替え」のみとする）。
- 履歴の検索機能や並べ替え機能。
- 全ホスト共通の履歴（サイトごとの検索クエリが異なるため、ホスト別に限定する）。

## Decisions

### 1. クエリの正規化ロジック
- **決定**: クエリを「小文字化 -> トリム -> 空白分割 -> ソート -> 結合」して比較する。
- **理由**: 「a b」と「b a」を確実に同一視するため。ソートすることで、入力順序に依存しないユニークなキーを得られる。

### 2. 履歴保存のタイミングと場所
- **決定**: `UIManager._performSearch` 内で検索成功（fetch開始前または後）時に更新し、`Store` を介して `localStorage` に保存する。
- **理由**: 検索実行というユーザーの意図が明確なタイミングで記録するのが自然であるため。

### 3. 定数の配置
- **決定**: `src/store.ts` に `MAX_SEARCH_HISTORY = 3` を定義する。
- **理由**: 履歴のライフサイクル（ロード・保存・制限）を管理する `Store` がこの知識を持つのが最も凝集度が高い。

### 4. UI 構成
- **決定**: `SearchModal` の入力フォーム直下に `flex-wrap: wrap` のコンテナを作成し、履歴項目を小さなボタンとして表示する。
- **理由**: 入力フィールドからの視線移動が少なく、モバイル等のタッチ操作でも選択しやすいため。

## Risks / Trade-offs

- **[Risk] localStorage の容量制限**
  - **Mitigation**: 履歴は最大3件かつ文字列のみであるため、容量への影響は極めて軽微である。
- **[Trade-off] 正規化による意図しない重複**
  - **Mitigation**: 極めて稀なケース（例：「A B」と「B A」という異なる意味を持つ特殊な検索エンジン）を除き、一般的なキーワード検索ではメリットが上回る。今回のターゲットサイト群では問題ないと判断。
