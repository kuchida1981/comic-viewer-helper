## Context

現在のプロジェクトでは、キーボードや GUI ボタンを用いたページ遷移が実装されていますが、マウス操作中心のユーザーにとって、ホイールによる直感的なナビゲーションが欠けています。
スクリプトが有効な間、ブラウザのデフォルトのスクロール挙動を一部制御し、ページ単位のジャンプに変換する仕組みを設計します。

## Goals / Non-Goals

**Goals:**
- マウスホイールの回転を検知し、前後のページへジャンプする。
- トラックパッドや高速スクロールによる意図しない多重ジャンプを抑制する。
- 単一ページ表示と見開き表示の両方に対応する。

**Non-Goals:**
- ページ内での自由なピクセル単位のスクロールの維持（スクリプト有効時はページジャンプを優先する）。
- 水平スクロールホイールへの対応。

## Decisions

### 1. `wheel` イベントのグローバルリスナー
- **決定**: `window` オブジェクトに `passive: false` で `wheel` イベントリスナーを登録する。
- **理由**: コンテナ外にマウスがある場合でも操作を有効にするため。また、デフォルトのスクロールを抑制するために `preventDefault()` が必要になる可能性がある。

### 2. クールダウン（スロットル）処理
- **決定**: 最後にジャンプしてから 500ms のクールダウン期間を設ける。
- **理由**: トラックパッドの慣性スクロールや高速なホイール回転によって、一気に数ページ飛んでしまうのを防ぐため。
- **代替案**: デバウンス処理（操作が止まってからジャンプ）。しかし、これは反応が遅く感じるため、最初のイベントで即座に反応するスロットルの方が適している。

### 3. スクロール量の閾値（Threshold）
- **決定**: `Math.abs(event.deltaY)` が 50 以上の時のみ反応する。
- **理由**: マウスに触れた際などの微小な入力を無視するため。

### 4. ジャンプ先の決定ロジック
- **単一ページ表示**: `currentVisibleIndex` を基に `+1` または `-1` のインデックスへ `jumpToPage` を実行する。
- **見開き表示**: 見開き単位で移動したいため、`+2` または `-2` を基本とする。ただし、`fitImagesToViewport` で構築された実際の「行（row）」を意識する必要がある。
- **簡略化**: `jumpToPage(index)` は既に存在する関数であり、ターゲット画像に `scrollIntoView` する。見開き表示時でも、適切なインデックスを指定すればブラウザがその見開き（行）までスクロールしてくれるため、既存の `jumpToPage` を再利用する。

## Risks / Trade-offs

- **[Risk]** ブラウザのデフォルトスクロールが一切できなくなる。
  - **Mitigation**: `isEnabled` が `false` の時はリスナーを無効化するか、何もしない。また、ページジャンプが実行されたイベントのみ `preventDefault()` を呼ぶように検討する。
- **[Risk]** トラックパッドの感度差による誤動作。
  - **Mitigation**: クールダウン期間を調整可能にするか、十分な長さに設定する（500ms）。
