## Context

現在のプロジェクトでは、キーボードや GUI ボタンを用いたページ遷移が実装されていますが、マウス操作中心のユーザーにとって、ホイールによる直感的なナビゲーションが欠けています。
スクリプトが有効な間、ブラウザのデフォルトのスクロール挙動を一部制御し、ページ単位のジャンプに変換する仕組みを設計します。

## Goals / Non-Goals

**Goals:**
- マウスホイールの回転を検知し、前後のページへジャンプする。
- トラックパッドや高速スクロールによる意図しない多重ジャンプを抑制する。
- 単一ページ表示と見開き表示の両方に対応する。
- **ピクセル単位の微細なスクロールを完全に禁止し、常にページ単位で整列させる。**

**Non-Goals:**
- 水平スクロールホイールへの対応。

## Decisions

### 1. `wheel` イベントのグローバルリスナー
- **決定**: `window` オブジェクトに `passive: false` で `wheel` イベントリスナーを登録し、**すべての `wheel` イベントに対して `preventDefault()` を実行する**。
- **理由**: スクリプト有効時にブラウザ標準のスクロールが発生すると、表示位置が画像の中途半端な場所で止まってしまうため。これを防ぐには、ページ移動が発生しない微小な回転であっても標準の挙動を抑制する必要がある。

### 2. クールダウン（スロットル）処理
- **決定**: 最後にジャンプしてから 500ms のクールダウン期間を設ける。
- **理由**: トラックパッドの慣性スクロールや高速なホイール回転によって、一気に数ページ飛んでしまうのを防ぐため。
- **代替案**: デバウンス処理（操作が止まってからジャンプ）。しかし、これは反応が遅く感じるため、最初のイベントで即座に反応するスロットルの方が適している。

### 3. スクロール量の閾値（Threshold）
- **決定**: `Math.abs(event.deltaY)` が **1 以上**の時（＝わずかでも回転した時）に反応する。
- **理由**: 微小なスクロールであっても、標準スクロールによる表示位置のズレ（中途半端な位置での停止）を防ぎ、常にページ単位の移動を保証するため。

### 4. ジャンプ先の決定ロジック
- **単一ページ表示**: `currentVisibleIndex` を基に `+1` または `-1` のインデックスへ `jumpToPage` を実行する。
- **見開き表示**: 見開き単位で移動したいため、`+2` または `-2` を基本とする。ただし、`fitImagesToViewport` で構築された実際の「行（row）」を意識する必要がある。
- **簡略化**: `jumpToPage(index)` は既に存在する関数であり、ターゲット画像に `scrollIntoView` する。見開き表示時でも、適切なインデックスを指定すればブラウザがその見開き（行）までスクロールしてくれるため、既存の `jumpToPage` を再利用する。

## Risks / Trade-offs

- **[Risk]** ブラウザのデフォルトスクロールが一切できなくなる。
  - **Mitigation**: `isEnabled` が `false` の時はリスナーを無効化するか、何もしない。また、ページジャンプが実行されたイベントのみ `preventDefault()` を呼ぶように検討する。
- **[Risk]** トラックパッドの感度差による誤動作。
  - **Mitigation**: クールダウン期間を調整可能にするか、十分な長さに設定する（500ms）。
