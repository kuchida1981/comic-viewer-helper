## Context

現在の `Navigator.scrollToEdge` は同期的に実装されており、単に `scrollIntoView` を呼び出すだけです。しかし、画像が遅延読み込み（`loading="lazy"`）されている場合や、まだロードが完了していない場合、ブラウザは正しい位置にスクロールできないことがあります。`jumpToPage` や `scrollToImage` メソッドでは既にこの問題に対処するための非同期ロード待機ロジックが実装されていますが、`scrollToEdge` にはこのロジックが欠如しています。

## Goals / Non-Goals

**Goals:**
- `scrollToEdge` メソッドで、未ロードの画像（最初または最後）へ移動する場合でも、正しくロードを待機してからスクロールすること
- `scrollToEdge` のシグネチャを `async` に変更し、非同期処理を適切に扱うこと
- 既存の `jumpToPage` や `scrollToImage` と同様の一貫した挙動を提供すること

**Non-Goals:**
- ナビゲーション UI の大幅なデザイン変更
- 画像ロード処理自体のパフォーマンス最適化（あくまでロード待機の仕組みを適用するのみ）

## Decisions

### 1. `scrollToEdge` の非同期化
`scrollToEdge` を `async` メソッドに変更し、内部で `forceImageLoad` と `waitForImageLoad` を使用します。これにより、呼び出し元も `await` できるようになりますが、主な利用箇所であるイベントハンドラでは単に非同期実行されることになります。

### 2. ロジックの共通化について
`jumpToPage` や `scrollToImage` とロジックが重複しますが、今回は既存の実装パターン（各メソッド内でロード処理を行う）を踏襲し、`scrollToEdge` 内に同様の処理を記述します。無理な共通化による複雑化を避けるためです。

### 3. `applyLayout` の呼び出し
画像ロード完了後、スクロール前に `applyLayout` を呼び出して、見開き表示などのレイアウト計算を強制的に更新します。これにより、スクロール位置のズレを防ぎます。

## Risks / Trade-offs

**Risks:**
- 既に `scrollToEdge` を同期メソッドとして依存しているコードがある場合、挙動が変わる可能性がありますが、現状のコードベース調査では UI イベントハンドラからの呼び出しが主であるため、大きな影響はないと判断します。

**Trade-offs:**
- 非同期化により、ボタンを押してから実際にスクロールが始まるまでに若干の遅延（ロード待ち時間）が発生する可能性がありますが、ローディングインジケータ（`store.setState({ isLoading: true })`）を表示することでユーザーにフィードバックを提供します。
