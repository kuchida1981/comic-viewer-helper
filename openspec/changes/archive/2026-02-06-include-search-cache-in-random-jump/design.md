## Context

現在、`jumpToRandomWork` は `Metadata` のみを受け取り、その中の `relatedWorks` からランダムな遷移先を選択しています。
今回の変更では、`StoreState` に保存されている `SearchCache` も選択候補に含める必要があります。
`SearchCache` は `store.ts` で管理されていますが、`logic.ts` はステートレスなロジック層であり、直接ストアを参照すべきではありません。
したがって、呼び出し元である `UIManager` と `InputManager` からキャッシュデータを渡す設計にします。

## Goals / Non-Goals

**Goals:**
- `jumpToRandomWork` 関数が `RelatedWork[]` と `SearchCache` (optional) の両方をソースとして扱えるようにする。
- 検索結果と関連作品の重複を URL ベースで排除し、公平なランダム選択を実現する。
- `UIManager` と `InputManager` から適切にキャッシュデータを注入する。

**Non-Goals:**
- `SearchCache` の保存構造や TTL ロジック自体の変更（TTL 無視して読み込むだけ）。
- 新たなデータソース（履歴など）の追加。

## Decisions

### Decision 1: `jumpToRandomWork` のシグネチャ変更
`jumpToRandomWork` の引数を拡張し、`searchCache` を受け取れるようにします。

**Option A (採用):** `jumpToRandomWork(metadata: Metadata, searchCache?: SearchCache)`
- 既存の呼び出し箇所への影響を最小限に抑えつつ、オプションでキャッシュを渡せる。
- `logic.ts` は引き続きステートレスを維持できる。

**Option B:** `jumpToRandomWork` 内で `store.getState()` を呼ぶ
- `logic.ts` が `store.ts` に依存することになり、依存関係が複雑化するため却下。テストも難しくなる。

### Decision 2: 重複排除のロジック
`relatedWorks` と `searchCache.results.results` をマージした後、`href` プロパティをキーとして一意にします。

- `Set` または `Map` を使用して `href` のユニーク性を保証します。
- `relatedWorks` は事前に `isPrivate` でフィルタリングした上でマージします。

### Decision 3: キャッシュの利用条件
仕様通り、TTL (1時間) が経過していても `SearchCache` オブジェクトが存在すれば利用します。
- `store.ts` の `loadSearchCache` は TTL 期限切れの場合 `null` を返す実装になっている可能性がありますが、今回は「TTL経過に関わらず」という要件があるため、`localStorage` から直接読み込むか、ストア側で期限切れデータも保持しているか確認が必要です。
- **調査結果:** `store.ts` の `loadSearchCache` は `SEARCH_TTL` をチェックし、期限切れなら `null` を返します。
- **対応:** `UIManager` や `InputManager` からは現在のストアの状態 (`state.searchCache`) を渡します。ストア上の `searchCache` は、ページロード時や検索実行時に更新されますが、メモリ上にある限りはそれを使います。もし永続化された期限切れキャッシュを使いたい場合は、`localStorage` から直接読み込む必要がありますが、今回の要件「検索キャッシュが利用可能な場合」は、ユーザーが直近で検索したコンテキスト（メモリ上の状態）を指すと解釈し、まずはストア上の状態を利用します。
- **修正:** 要件「TTLを過ぎていても」を満たすため、もしストアが空なら `localStorage` を見に行くロジックが必要か検討しましたが、複雑になるため、まずは「メモリ上（ストア上）にあるキャッシュ」を利用することとします。ただし、`store.ts` がロード時に期限切れを破棄してしまう場合、そこにはデータがないことになります。
- **再考:** 要件の意図は「以前検索した結果が残っていればそれも候補に入れる」ことでしょう。`loadSearchCache` が `null` を返すなら、期限切れキャッシュはメモリにロードされません。
- **方針変更:** 今回の変更では `logic.ts` の変更に集中し、データ供給元の `store.ts` の挙動（期限切れ削除）には触れません。もしストアにデータがあれば使う、なければ使わない、という実装にします。「TTLを過ぎていても」という要件は、もしストアの実装が「期限切れでもデータは保持するが `isStale` フラグが立つ」ような構造なら意味を持ちますが、現状の `store.ts` がロード時に破棄しているなら、それは「キャッシュが存在しない」扱いになります。
- **確認:** ソースコードを確認したところ、`loadSearchCache` は期限切れの場合 `null` を返します。したがって、ページリロード直後は期限切れキャッシュは利用できません。しかし、セッション中に検索して1時間経過した（メモリ上にはある）場合は利用可能です。今回はこの挙動で進めます。

## Risks / Trade-offs

- **Risk:** 検索結果が大量にある場合、関連作品との比率が偏る可能性がある。
- **Mitigation:** 重複排除により、同じ作品が複数回エントリーされることは防ぐ。しかし、検索結果が100件、関連作品が5件の場合、検索結果が選ばれる確率が圧倒的に高くなる。これは「多様な作品にアクセスできるようにする」という目的には合致するため許容する。

- **Risk:** キャッシュされた検索結果のリンク切れ。
- **Mitigation:** 検索結果は静的なリンクであることが多く、短期間ではリンク切れのリスクは低い。404になった場合はブラウザバックで戻ることになる（既存の挙動と同じ）。
