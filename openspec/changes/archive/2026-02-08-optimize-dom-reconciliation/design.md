## Context

現在の `fitImagesToViewport` 関数は、実行のたびに `cleanupDOM` を呼び出して全ての `.comic-row-wrapper` を削除し、画像をフラットな状態に戻してから、再度ループ処理でラッパーを生成・画像を追加しています。
これは実装が単純である反面、ブラウザのレイアウト計算とDOM生成コストが毎回最大になります。特にリサイズイベントや見開き切り替え時において、不要な負荷がかかっています。

## Goals / Non-Goals

**Goals:**
- `fitImagesToViewport` 実行時のDOM操作（追加・削除）回数を最小限にする。
- 既存の画像ペアリングロジック（`shouldPairWithNext`）や表示ルール（最初のページは単独など）を維持する。
- 画面のちらつきやスクロール位置のズレを軽減する。

**Non-Goals:**
- 画像の読み込み処理（`waitForImageLoad`）自体の最適化（これは別スコープ）。
- 仮想スクロール（Virtualization）の導入（今回は既存DOM構造の最適化に留める）。

## Decisions

### 1. Reconciliation（差分更新）アルゴリズムの採用

全削除・全生成ではなく、現在のDOMの状態を確認しながら、必要な変更のみを適用するアプローチを採用します。

**ロジック詳細:**
1. 現在コンテナ内にある全ての画像を取得します。
2. 画像リストを先頭から順に処理します。
3. 各画像について「あるべき状態（Solo または Paired）」を判定します。
4. **現状確認**:
   - その画像が既に適切な `.comic-row-wrapper` に入っているか？
   - ペアの場合、隣の画像も正しくそのラッパーに入っているか？
5. **アクション**:
   - **一致する場合**: スタイルのみ更新（必要であれば）し、DOM構造は触らない。
   - **不一致の場合**:
     - 既存のラッパーから画像を移動（`appendChild` は移動として振る舞うため、古い親からは自動的に外れる）。
     - 必要に応じて新しい `.comic-row-wrapper` を生成、または空になった既存ラッパーを再利用/削除する。

### 2. ラッパーの再利用戦略

ラッパー要素自体も、可能な限り `remove()` せずに再利用します。
ループ処理中に「現在のカーソル位置にあるラッパー」を確認し、それが使えるなら使い、使えない（余っている）なら削除、足りなければ生成という戦略をとります。

**Alternatives Considered:**
- **オブジェクトプール**: 削除したラッパーを配列に保持しておき、次回生成時に再利用する。
  - **却下理由**: DOMツリー上の位置が重要であり、インプレースで更新する方が移動コストが低い。Reconciliationの方がより宣言的でバグが入りにくい。

## Risks / Trade-offs

- **複雑性**: 単純なループ生成に比べ、条件分岐が増え、ロジックが複雑になる。
  - **Mitigation**: ヘルパー関数（`ensureWrapper`, `updateWrapperStyle`）に切り出し、責務を分離する。
- **スタイル汚染**: 古いスタイルが残る可能性がある。
  - **Mitigation**: ラッパーや画像のスタイル適用時に、必要なプロパティを確実に上書きする。あるいは `cssText` で一括設定する。
